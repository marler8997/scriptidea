#!/usr/bin/env stitch
#
# What happens to bash pitfalls in stitch?
#
# These pitfalls are taken from https://mywiki.wooledge.org/BashPitfalls
#
@note '''

Summary
--------------------------------------------------------------------------------

# | Example                                 | Stitch Result
--|-----------------------------------------|-----------------------------------
1 | for f in $(ls *.mp3)                    | loops not implemented yet
2 | cp $file $target                        | fixed
3 | Filenames with leading dashes           | mitigated
4 | [ $foo = "bar" ]                        | fixed
5 | cd $(dirname "$f")                      | fixed
6 | [ "$foo" = bar && "$bar" = foo ]        | fixed
7 | [[ $foo > 7 ]]                          | fixed
8 | grep foo bar | while read -r; do ((count++)); done | loops not implemented yet
9 | if [grep foo myfile]                    | fixed
10| if [bar="$foo"]; then ...               | fixed
11| if [ [ a = b ] && [ c = d ] ]; then ... | fixed
12| read $foo                               | fixed
13| cat file | sed s/foo/bar/ > file        | not fixed

> NOTE: some of these pitfalls are only fixed so long as stitch scripts avoid use
of the '[' and '[[' programs.

'''

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #1: for f in $(ls *.mp3)
--------------------------------------------------------------------------------
Have not implemented any looping yet
'''

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #2: cp $file $target
--------------------------------------------------------------------------------
 In stitch this example is correct because:
     - variables can have whitespace and are still treated as single arguments
     - there's no $IFS
     - variables can have wildcards
     - there's no wordsplitting
     - there's no pathname expansion
'''

rm -rf @scriptdir/scratch
mkdir @scriptdir/scratch
file = @scriptdir''/scratch/file with crazy characters like *[{}]<>"'''
target = (@echo @scriptdir/scratch/the target file)
touch $file

cp $file $target

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #3: Filenames with leading dashes
--------------------------------------------------------------------------------
this isn't a problem with Bash, it's just a problem with command-line interfaces
in general that scripting languages are vulnerable to.

That being said, this issue is mitigated because currently stitch pathnaes are
absolute for the most part, although, this is subject to change.
'''

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #4: [ $foo = "bar" ]
--------------------------------------------------------------------------------
In stitch the correct syntax is:

     $foo @eq bar

We avoid the pitfalls because:
    - we don't have quoted variable semantics
    - if 'foo' does not exist then a "foo is undefined" error will be asserted rather than evaluating it as [ = "bar" ]
    - variables can have whitespace and are still treated as single arguments
    - there's no $IFS
    - variables can have wildcards
    - there's no wordsplitting
    - there's no pathname expansion
'''
foo = bar
@assert $foo @eq bar
foo = notbar
@assert @not ($foo @eq bar)

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #5: cd $(dirname "$f")
--------------------------------------------------------------------------------
Right now stitch does not support a `cd` command. The example below demonstrates
the alternatives in order of preference:

    Bash Example:
        cd $(dirname "$f")
        cat foo
        git status
        tar xf bar.tar

    Equivalent:
        dir = (dirname $f)
        cat $dir/foo
        git -C $dir status
        @withcwd $dir tar xf bar.tar

Note that unlike the BASH example, the equivalent example is "correct".
'''
rm -rf @scriptdir/scratch
mkdir @scriptdir/scratch
f = @scriptdir/scratch

dir = $f
ls $dir

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #6: [ "$foo" = bar && "$bar" = foo ]
--------------------------------------------------------------------------------
In stitch the equivalent command would be:

    ($foo @eq bar) @and ($bar @eq foo)

Stitch discourages use of `[` and `[[` which solves one of the problem with this.
Since stitch also doesn't have a `&&` operator, it avoid the other issue with this.
'''
foo = bar
bar = foo

@assert ($foo @eq bar) @and ($bar @eq foo)

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #7: [[ $foo > 7 ]]
--------------------------------------------------------------------------------
This one looks like a problem with the '[[' program rather than with BASH itself.
However, stitch's binary comparison operators return Bool objects that cannot
be passed to external programs, so this pitfall becomes a semantic type error in stitch.
'''
foo = 8

@assert $foo @gt 7

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #8: grep foo bar | while read -r; do ((count++)); done
--------------------------------------------------------------------------------
we don't have loops yet, but the underlying problem is that `count++` is
executed in a subshell, however, stitch doesn't execute inline-commands in subshells
so this pitfall should be avoided.
'''



@note '''
--------------------------------------------------------------------------------
Bash Pitfall #9: if [grep foo myfile]
--------------------------------------------------------------------------------
The pitfall here is that '[' looks like it's part of the "if" syntax but it's not.
In stitch the command `@if [grep foo myfile]` would cause a runtime error saying
unable to find program "[grep". The correct syntax would be:

    @if grep foo @callerworkdir/myfile

The problem BASH has is that the '['square brackets']' are necessary for many kinds
of conditional statements which increases the odds that a programmer will use them
incorrectly in this use case.  This is not a problem with BASH but instead with the
'[' program.  This means stitch scripts that make use of `[` are susceptible
to the same pitfall. However, stitch scripts have alternatives to `[` that make it
unnecessary and its use is discouraged to avoid its pitfals.
'''
touch @scriptdir/scratch/myfile
@if grep foo @scriptdir/scratch/myfile
    @unreachable
@end

(@echo foo) @pipe (@stdin2file @scriptdir/scratch/myfile)
@if @not grep foo @scriptdir/scratch/myfile
    @unreachable
@end


@note '''
--------------------------------------------------------------------------------
Bash Pitfall #10: if [bar="$foo"]; then ...
--------------------------------------------------------------------------------
Problem fixed by avoiding the '[' program
'''
@if $bar @eq $foo
    @echo success
@end

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #11: if [ [ a = b ] && [ c = d ] ]; then ...
--------------------------------------------------------------------------------
Problem fixed by avoiding the '[' program
'''

@if (a @eq b) @and (c @eq d)
    @echo here
@end

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #12: read $foo
--------------------------------------------------------------------------------
stitch doesn't have a read builtin so this pitfall is avoided.  The equivalent
here would be:

foo = (cat)
'''

foo = ((@echo the foo value) @pipe (cat))
@assert $foo @eq "the foo value"

@note '''
--------------------------------------------------------------------------------
Bash Pitfall #13: cat file | sed s/foo/bar/ > file
--------------------------------------------------------------------------------
This one is still a problem in stitch.  Stitch doesn't protect the programmer
from reading a file and writing to the same file being read from.  The equivalent
command for this right now would be:

(cat @callerworkdir/file) @pipe (sed s/foo/bar/) @pipe (@stdin2file @callerworkdir/file)

The corrected version would be:

(cat @callerworkdir/file) @pipe (sed s/foo/bar/) @pipe (@stdin2file @callerworkdir/filetmp)
mv @callerworkdir/filetmp @callerworkdir/file
'''
(@echo foo bar baz) @pipe (@stdin2file @scriptdir/scratch/file)

(cat @scriptdir/scratch/file) @pipe (sed s/foo/bar/) @pipe (@stdin2file @scriptdir/scratch/filetmp)
mv @scriptdir/scratch/filetmp @scriptdir/scratch/file

@assert (cat @scriptdir/scratch/file) @eq "bar bar baz"


@note cleaning up
rm -rf @scriptdir/scratch
