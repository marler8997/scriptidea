$#
$# An example script that enumerates BASH pitfalls and how they would
$# compare to this scripting language:
$#
$# These pitfalls are taken from https://mywiki.wooledge.org/BashPitfalls
$#

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #1: for f in $(ls *.mp3)"
$note --------------------------------------------------------------------------------
$note Have not implemented any looping yet

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #2: cp $file $target"
$note --------------------------------------------------------------------------------
$#
$# This examples is correct in this scripting language because:
$#     - variables can have whitespace and are still treated as a single argument
$#     - there's no $IFS
$#     - variables can have wildcards
$#     - there's no wordsplitting
$#     - there's no pathname expansion
$#
rm -rf scratch
mkdir scratch
$set file ($echo scratch/file with crazy characters like *[{}]<>")
$set target ($echo scratch/the target file)
touch $file

cp $file $target

$note --------------------------------------------------------------------------------
$note Bash Pitfall #3: Filenames with leading dashes
$note --------------------------------------------------------------------------------
$note this isn't a problem with Bash, it's just a problem with command-line interfaces
$note in general that scripting languages are vulnerable to.

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #4: [ $foo = "bar" ]
$note --------------------------------------------------------------------------------
$#
$# In this scripting language, the correct usage is
$#     [ $foo = bar ]
$#
$# We avoid the pitfalls because:
$#     - we don't have quoted variable semantics
$#     - if 'foo' does not exist then a "foo is undefined" error will be asserted rather than evaluating it as [ = "bar" ]
$#     - variables can have whitespace and are still treated as a single argument
$#     - there's no $IFS
$#     - variables can have wildcards
$#     - there's no wordsplitting
$#     - there's no pathname expansion
$#
$set foo bar
[ $foo = bar ]
$set foo notbar
[ 1 = ($captureexitcode [ $foo = bar ]) ]

$note cleaning up
rm -rf scratch