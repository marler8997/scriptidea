#
# An example script that enumerates BASH pitfalls and how they would
# compare to this scripting language:
#
# These pitfalls are taken from https://mywiki.wooledge.org/BashPitfalls
#
$set scriptdir (dirname $scriptfile)

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #1: for f in $(ls *.mp3)"
$note --------------------------------------------------------------------------------
$note Have not implemented any looping yet

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #2: cp $file $target"
$note --------------------------------------------------------------------------------
#
# This examples is correct in this scripting language because:
#     - variables can have whitespace and are still treated as a single argument
#     - there's no $IFS
#     - variables can have wildcards
#     - there's no wordsplitting
#     - there's no pathname expansion
#
rm -rf $scriptdir/scratch
mkdir $scriptdir/scratch
$set file $scriptdir/scratch/$@|file with crazy characters like *[{}]<>"'|
$set target ($echo $scriptdir/scratch/the target file)
touch $file

cp $file $target

$note --------------------------------------------------------------------------------
$note Bash Pitfall #3: Filenames with leading dashes
$note --------------------------------------------------------------------------------
$note this isn't a problem with Bash, it's just a problem with command-line interfaces
$note in general that scripting languages are vulnerable to.

$note --------------------------------------------------------------------------------
$note $@"Bash Pitfall #4: [ $foo = "bar" ]
$note --------------------------------------------------------------------------------
#
# In this scripting language, the correct usage is
#     [ $foo = bar ]
#
# We avoid the pitfalls because:
#     - we don't have quoted variable semantics
#     - if 'foo' does not exist then a "foo is undefined" error will be asserted rather than evaluating it as [ = "bar" ]
#     - variables can have whitespace and are still treated as a single argument
#     - there's no $IFS
#     - variables can have wildcards
#     - there's no wordsplitting
#     - there's no pathname expansion
#
$set foo bar
[ $foo = bar ]
$set foo notbar
[ 1 = ($captureexitcode [ $foo = bar ]) ]

$note --------------------------------------------------------------------------------
$note $@'Bash Pitfall #5: cd $(dirname "$f")'
$note --------------------------------------------------------------------------------
# Right now this scripting language does not support a `cd` command. The example
# below demonstrates the alternatives in order of preference:
#
#     Bash Example:
#         cd $(dirname "$f")
#         cat foo
#         git status
#         tar xf bar.tar
#
#     Equivalent:
#         $set dir (dirname $f)
#         cat $dir/foo
#         git -C $dir status
#         $cwd $dir tar xf bar.tar
#
# Note that unlike the BASH example, the equivalent example is "correct".
rm -rf $scriptdir/scratch
mkdir $scriptdir/scratch
$set f $scriptdir/scratch

$set dir $f
ls $dir

$note --------------------------------------------------------------------------------
$note $@'Bash Pitfall #6: [ "$foo" = bar && "$bar" = foo ]'
$note --------------------------------------------------------------------------------
# this scripting language currently doesn't have an equivalent of "&&" so this one
# can't happen, however, I also don't have a good alternative for "&&" at this point.
# Here is the corrected BASH example:
#
#     [ $foo = bar ] && [ $bar = foo ]
#
$set foo bar
$set bar foo

# TODO: how to represent this?
#[ $foo = bar ] && [ $bar = foo ]
$set test1 ($captureexitcode [ $foo = bar ])
$set test2 ($captureexitcode [ $bar = foo ])
$echo test1 is $test1, test2 is $test2

$note --------------------------------------------------------------------------------
$note $@'Bash Pitfall #7: [[ $foo > 7 ]]'
$note --------------------------------------------------------------------------------
# this one looks like a problem with the '[[' program rather than with BASH itself

$note --------------------------------------------------------------------------------
$note $@'Bash Pitfall #8: grep foo bar | while read -r; do ((count++)); done'
$note --------------------------------------------------------------------------------
# we don't have loops yet, but the underlying problem is that `count++` is
# executed in a subshell, however, this script doesn't do that so it shouldn't
# be a pitfall



$note cleaning up
rm -rf scratch
