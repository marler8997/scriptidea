#!/usr/bin/env python3
import sys
import os
import subprocess
import inspect
from abc import ABC, abstractmethod
from typing import List, Dict, Union, Tuple, Any, Optional

import lex
import parse
import prototype

SCRIPT_DIR_STR = os.path.dirname(__file__)
SCRIPT_DIR = SCRIPT_DIR_STR.encode('utf8')

class ErrorReader(prototype.Reader):
    @staticmethod
    def descriptor():
        return "error"
    def read(self) -> Optional[bytes]:
        raise Exception("stdin has been disabled for this test")
ERROR_READER = ErrorReader()
class StringReader(prototype.Reader):
    def __init__(self, s: bytes):
        self.s: Optional[bytes] = s
    @staticmethod
    def descriptor():
        return "string"
    def read(self) -> Optional[bytes]:
        result = self.s
        self.s = None
        return result

class Options:
    def __init__(self, verification_mode: bool, stdin: Optional[bytes] = None):
        if stdin is not None:
            assert(isinstance(stdin, bytes))
            assert(not verification_mode)
        self.verification_mode = verification_mode
        self.stdin = stdin
    def getStdinReader(self) -> prototype.Reader:
        if self.stdin:
            assert(not self.verification_mode)
            return StringReader(self.stdin)
        return ERROR_READER

def runInternal(line: bytes, options: Options):
    context = prototype.ScriptContext(prototype.GlobalContext(True, SCRIPT_DIR), __file__.encode('utf8'), line, options.verification_mode)

    stdout = prototype.newCaptureWriter(options.verification_mode)
    stderr = prototype.newCaptureWriter(options.verification_mode)
    nodes, end = parse.parseCommand(line, 0, context.allstringliterals)
    assert(end == len(line))
    assert(len(nodes) > 0)
    result = prototype.runCommandNodes(prototype.CommandContext(
        context, parent=None, depth=0,
        capture=prototype.Capture(False, stdout, stderr, options.getStdinReader()),
        builtin_prefix_count=0, ambiguous_op=None), nodes)
    return result, prototype.getCaptureWriterOutput(stdout), prototype.getCaptureWriterOutput(stderr)

class Expect(ABC):
    @abstractmethod
    def verify(self, result, stdout: Union[bytes,prototype.UnknownString], stderr: Union[bytes,prototype.UnknownString], test_line: int):
        pass
class ExpectExitAndStdout(Expect):
    def __init__(self, exitcode: int, stdout: bytes):
        self.exitcode = exitcode
        self.stdout = stdout
    def verify(self, result, stdout: Union[bytes,prototype.UnknownString], stderr: Union[bytes,prototype.UnknownString], test_line: int):
        if type(result) != prototype.ExitCode:
            sys.exit("{}({}): Error: expected an ExitCode but got {}: {}".format(__file__, test_line, type(result).__name__, result))
        if result.value != self.exitcode:
            sys.exit("{}({}): Error: expected Command to return exitcode {} but got {}".format(
                __file__, test_line, self.exitcode, result.exitcode.value))
        if stdout != self.stdout:
            sys.exit("{}({}): Error: expected Command to print {!r} but got {!r}".format(
                __file__, test_line, self.stdout, stdout))
class ExpectError(Expect):
    def __init__(self, error_type, message):
        self.error_type = error_type
        self.message = message
    def verify(self, result, stdout: Union[bytes,prototype.UnknownString], stderr: Union[bytes,prototype.UnknownString], test_line: int):
        if not isinstance(result, self.error_type):
            sys.exit("{}({}): Error: expected a {} but got {}: '{}'".format(
                __file__, test_line, self.error_type.__name__, type(result).__name__, result))
        result_msg = str(result)
        if result_msg != self.message:
            print("{}({}): Error: {} message does not match expected:".format(__file__, test_line, self.error_type.__name__))
            print("expected: {}".format(self.message))
            print("actual  : {}".format(result_msg))
            sys.exit(1)

def runTest(src: bytes, expect: Expect, test_line: int, options: Options):
    context = prototype.ScriptContext(prototype.GlobalContext(True, SCRIPT_DIR), __file__.encode('utf8'), src, options.verification_mode)
    stdout = prototype.newCaptureWriter(options.verification_mode)
    stderr = prototype.newCaptureWriter(options.verification_mode)
    result: Any = None
    try:
        result = prototype.runScript(context, stdout, stderr, options.getStdinReader())
    except lex.SyntaxError as e:
        result = e
    expect.verify(result, prototype.getCaptureWriterOutput(stdout), prototype.getCaptureWriterOutput(stderr), test_line)

def getCallerLine():
    return inspect.getframeinfo(inspect.stack()[2][0]).lineno

def testCommand(src: bytes, exitcode: int, stdout: bytes, options: Options = Options(verification_mode=False)):
    expect = ExpectExitAndStdout(exitcode, stdout)
    print("testCommand({!r}, exitcode={}, stdout{!r}".format(src, exitcode, stdout))
    runTest(src, expect, getCallerLine(), options)

def testError(src: bytes, error_type, message: str, options: Options = Options(verification_mode=True)):
    expect = ExpectError(error_type, message)
    print("testError({!r}, {}, {})".format(src, error_type.__name__, message))
    runTest(src, expect, getCallerLine(), options)

def testSyntaxError(src: bytes, message: str):
    expect = ExpectError(lex.SyntaxError, message)
    print("testSyntaxError({!r}, {})".format(src, message))
    runTest(src, expect, getCallerLine(), Options(verification_mode=True))

def testSemanticError(src: bytes, message: str):
    expect = ExpectError(prototype.SemanticError, message)
    print("testSemanticError({!r}, {})".format(src, message))
    runTest(src, expect, getCallerLine(), Options(verification_mode=True))

def testAssertError(src: bytes, options: Options = Options(verification_mode=True)):
    expect = ExpectError(prototype.AssertError, "@assert failed")
    print("testAssertError({!r})".format(src))
    runTest(src, expect, getCallerLine(), options)

def testBoolExpression(line: bytes, expected: bool):
    print("testBoolExpression({!r}, {})".format(line, expected))
    result, stdout, stderr = runInternal(line, Options(verification_mode=False))
    if not isinstance(result, prototype.Bool):
        sys.exit("Error: expected expression to return Bool but got {}: {}".format(type(result).__name__, result))
    assert(expected == result.value)

def testArrayExpression(line: bytes, expected: prototype.Array):
    print("testArrayExpression({!r}, {})".format(line, expected))
    result, stdout, stderr = runInternal(line, Options(verification_mode=False))
    test_line = getCallerLine()
    if not isinstance(result, prototype.Array):
        sys.exit("Error: expected expression to return Array but got {}: {}".format(type(result).__name__, result))
    if len(expected.elements) != len(result.elements):
        sys.exit("{}({}): Error: expected an array of {} elements but got {}".format(
            __file__, test_line, len(expected.elements), len(result.elements)))
    for i in range(0, len(expected.elements)):
        if len(expected.elements[i]) != len(result.elements[i]):
            sys.exit("{}({}): Error: elements at index {} '{!r}' does not match expected '{!r}'".format(
                __file__, test_line, i, result.elements[i], expected.elements[i]))

def printForceNewline(s: bytes):
    print(s, end=("" if s.endswith(b"\n") else "\n"))

def expectMatches(output: bytes, matches: List[bytes]):
    for match in matches:
        if match not in output:
            print("Error: did not find expected output")
            print()
            print("Expected:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(match)
            print("--------------------------------------------------------------------------------")
            print("Actual:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(output)
            print("--------------------------------------------------------------------------------")
            sys.exit(1)

def expectMatch(actual: str, expected: str):
    if actual != expected:
        print("Error: unexpectd output:")
        print("Expected: '{}'".format(expected))
        print("Actual: '{}'".format(actual))
        sys.exit(1)

def runSubProcessTest(exit_code: int, args: List[str]):
    print("Running: {}".format(args))
    result = subprocess.run(args, capture_output=True)
    if result.returncode != exit_code:
        print("Error: expected exit code {} but got {}".format(exit_code, result.returncode))
        print("STDOUT:\n--------\n{}\nSTDERR\n--------\n{}\n".format(result.stdout.decode('utf8'), result.stderr.decode('utf8')))
        sys.exit(1)
    return result.stdout, result.stderr

def runStitchTests():
    print("test: running stitch-tests...")
    stitch_args = [sys.executable, os.path.join(SCRIPT_DIR_STR, "prototype.py")]

    stdout, stderr = runSubProcessTest(0, stitch_args + ["-c", "@echo hello"])
    expectMatch(stdout.rstrip(), b"hello")

    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", "@missing"])
    expectMatch(stdout, b"")
    expectMatches(stderr, b"<the -c command>: SemanticError: '@missing' is undefined")

    if os.name == "nt":
        make_foo_cmd = "fsutil file createnew foo 0"
    else:
        make_foo_cmd = "touch foo"
    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", make_foo_cmd])
    expectMatches(stderr, [
        b"this script must be using relative filenames because the sandbox has this file ",
        b"1 file(s) were cleaned from the sandbox",
    ])

    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", "\n\n @!"])
    expectMatches(stderr, [b"(line 3 column 2) unrecognized character sequence '@!'"])

    result = subprocess.run(stitch_args + ["stitch-tests"])
    if result.returncode != 0:
        sys.exit(result.returncode)

def main():
    if os.name == "nt":
        path = os.path.join(SCRIPT_DIR_STR, "assetsfortest", "missing_windows_programs")
        os.environ["PATH"] = path + ";" + os.environ["PATH"]

    testSyntaxError(b"(", "missing close paren for: (")
    testSyntaxError(b"(foo", "missing close paren for: (foo")
    testSyntaxError(b"(a long command that demonstrates we shouldnt print this whole thing when we show an error",
                    "missing close paren for: (a long command that demonstra[..snip..]")
    testSyntaxError(b"$$", "unrecognized character sequence '$$'")
    testSyntaxError(b"@`", "unrecognized character sequence '@`'")
    testCommand(b"@echo @@", 0, b"@\n")
    testCommand(b"@echo @#", 0, b"#\n")
    testCommand(b"@echo @$", 0, b"$\n")
    testCommand(b"@echo @)", 0, b")\n")
    testCommand(b"@echo @(", 0, b"(\n")
    testCommand(b"@echo @=", 0, b"=\n")
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b"@echo @'", 0, b"'\n")

    testSemanticError(b"@multiline", "@multiline requires at least 1 argument")
    testSemanticError(b"@multiline @true", "the @multiline builtin is only supported within an (..inline command..)")
    testSemanticError(b"(@multiline @true @and @true)", "@multiline does not accept Bool")

    testSemanticError(b"@false", "unhandled Bool")
    testSemanticError(b"@true", "unhandled Bool")

    testSemanticError(b"@true dat", "unexpected Bool at the start of a command")

    testCommand(b'@echo', 0, b"")
    testCommand(b'@echo foo', 0, b"foo\n")
    testCommand(b'@echo "foo"', 0, b"foo\n")

    #
    # double-quoted string literals
    #
    testSyntaxError(b'"', 'missing double-quote to close: "')
    testSyntaxError(b'@echo "foo', 'missing double-quote to close: "foo')
    testSyntaxError(b'@echo "01234567890123456789012345678',
                    'missing double-quote to close: "01234567890123456789012345678')
    testSyntaxError(b'@echo "012345678901234567890123456789',
                    'missing double-quote to close: "01234567890123456789012345678[..snip..]')
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b'@echo "#@$()"', 0, b'#@$()\n')

    #
    # single-quoted string literals
    #
    testSyntaxError(b"'", "missing single-quote to close: '")
    testSyntaxError(b"''", "missing 2 single-quote sequence to close: ''")
    testSyntaxError(b"'''", "missing 3 single-quote sequence to close: '''")
    testSyntaxError(b"''''", "missing 4 single-quote sequence to close: ''''")
    testSyntaxError(b"'''''", "missing 5 single-quote sequence to close: '''''")
    testSyntaxError(b"''''''", "missing 6 single-quote sequence to close: ''''''")
    testSyntaxError(b"'''''''", "missing 6 single-quote sequence to close: '''''''")
    testSyntaxError(b"'a", "missing single-quote to close: 'a")
    testSyntaxError(b"''a", "missing 2 single-quote sequence to close: ''a")
    testSyntaxError(b"'''a", "missing 3 single-quote sequence to close: '''a")
    testSyntaxError(b"''''a", "missing 4 single-quote sequence to close: ''''a")
    testSyntaxError(b"@echo 'foo", "missing single-quote to close: 'foo")
    testSyntaxError(b"@echo '01234567890123456789012345678",
                    "missing single-quote to close: '01234567890123456789012345678")
    testSyntaxError(b"@echo '012345678901234567890123456789",
                    "missing single-quote to close: '01234567890123456789012345678[..snip..]")
    testCommand(b'@echo "#@$()"', 0, b"#@$()\n")

    testSyntaxError(b"@echo '\n", "missing single-quote to close: '")
    testSyntaxError(b"@echo ''\n''", "missing 2 single-quote sequence to close: ''")
    testCommand(b"@echo '''\n'''", 0, b"")
    testCommand(b"@echo '''\nhello'''", 0, b"hello\n")
    testCommand(b"@echo '''\nhello\nworld'''", 0, b"hello\nworld\n")
    testCommand(b"@echo '''\n\"hello\"\n'world''''", 0, b"\"hello\"\n'world'\n")

    testCommand(b"@echo 'hello\"'", 0, b"hello\"\n")
    testCommand(b"@echo ''hello\"'''", 0, b"hello\"'\n")
    testCommand(b"@echo '''hello\"''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''hello\"'''''", 0, b"hello\"'\n")
    testCommand(b"@echo '''''hello\"''''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''''hello\"'''''''", 0, b"hello\"'\n")

    # should be a syntax error because there are no quotes!
    testSyntaxError(b"@echo 'foo'", "got a single-quote string literal without double-quotes nor newlines, use double quotes instead or invoke @allstringliterals")
    testCommand(b"@allstringliterals\n@echo 'foo'", 0, b"foo\n")
    testCommand(b"\n".join([
        b"name = joe",
        b"age = 64",
        b"@echo '''\nhello '''$name''', you're\n64!!!'''"]
    ), 0, b"hello joe, you're\n64!!!\n")

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # TODO: test all the inline command prefixes
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    testSemanticError(b"@exitcode true", "the @exitcode builtin is only supported within an (..inline command..)")
    testSemanticError(b"@assert (@exitcode)", "@exitcode requires at least 1 argument")
    testSemanticError(b"@assert (@exitcode @exitcode true)", "@exitcode is not compatible with @exitcode")
    testSemanticError(b"@assert (@exitcode true @exitcode)", "cannot coerce Builtin '@exitcode' to String")
    testSemanticError(b"@assert (@exitcode @true)", "unhandled Bool")
    testSemanticError(b"@assert (@exitcode @multiline true)", "got @multiline but stdout is not being captured?  what's going on?")
    testCommand(b"@assert (@exitcode true)", 0, b"")
    testCommand(b"@assert @not (@exitcode false)", 0, b"")

    testSyntaxError(b"1@and", "'@and' requires space separation")
    testSyntaxError(b"@and=", "'@and' requires space separation")
    testSyntaxError(b"=@and", "'=' requires space separation")
    testSemanticError(b"@and", "unexpected '@and'")
    testSemanticError(b"@or", "unexpected '@or'")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"(@array) @and @true", "'@and' does not accept objects of type Array")
    testSemanticError(b"@true @and (@array)", "'@and' does not accept objects of type Array")
    testSemanticError(b"@false @and", "missing operand after '@and'")
    testSemanticError(b"(true) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"(false) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"false false @or", "unexpected '@or'")
    testSemanticError(b"(false) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@multiline true) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@and)", "unexpected '@and'")
    testSemanticError(b"(@and) @or", "unexpected '@and'")
    testSemanticError(b"@false @and false false", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @and @false false", "expected '@and' operator but got token 'false'; commands must be wrapped with (...)")
    testSemanticError(b"@false @and @false @or @false", "'@and' and '@or' cannot be chained")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"@true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"true @and (true)", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @or @false @and @false", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @or @true @and @true", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @and @true @or @true", "'@and' and '@or' cannot be chained")
    testSemanticError(b"@false @or @false @or false", "'@or' does not accept objects of type String")

    # TODO: implement stderr error messages
    testCommand(b"false", 1, b"")
    testSemanticError(b"@false @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or @false", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(true) @or (true)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (true)", "'@or' does not accept objects of type String")
    testBoolExpression(b"(@exitcode false) @or (@exitcode false)", False)
    testBoolExpression(b"(@exitcode false) @or (@exitcode true)", True)
    testBoolExpression(b"@true @or @undefined", True)
    testBoolExpression(b"@true @or $undefined", True)
    testBoolExpression(b"(@exitcode true) @or (@exitcode @undefined)", True)
    testSemanticError(b"@true @and ($missing)", "'$missing' is undefined")
    testSemanticError(b"(true) @and (false)", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode true) @and (@exitcode false)", False)
    testSemanticError(b"(true) @and (true)", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode true) @and (@exitcode true)", True)
    testBoolExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode false)", False)
    testBoolExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode true)", True)
    testBoolExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode false)", False)
    testBoolExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode true)", True)

    testBoolExpression(b"@false @and @false", False)
    testBoolExpression(b"@false @and @true", False)
    testBoolExpression(b"@true @and @false", False)
    testBoolExpression(b"@true @and @true", True)

    testBoolExpression(b"@false @or @false", False)
    testBoolExpression(b"@false @or @true", True)
    testBoolExpression(b"@true @or @false", True)
    testBoolExpression(b"@true @or @true", True)

    testCommand(b"(@echo true)", 0, b"")

    testSemanticError(b"$missing @and @true", "'$missing' is undefined")
    testSemanticError(b"(@echo hello) @and @true", "'@and' does not accept objects of type String")
    testCommand(b"@assert (@exitcode @echo hello) @and @true", 0, b"hello\n")

    testSemanticError(b"((@echo true)) @and @true", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode (@echo true)) @and @true", True)

    testSemanticError(b"abc@false @and @true", "cannot coerce Bool to String")
    testSemanticError(b"abc@scriptfile @and @true", "'@and' does not accept objects of type String")

    testSemanticError(b"@assert (@exitcode @true @and @true)", "@exitcode is not compatible with binary expressions")
    # todo: update this test when @stderr is defined
    testSemanticError(b"@assert (@stderr @true @and @true)", "'@stderr' is undefined")

    testSemanticError(b"@assert (@exitcode @haveprog foo)", "@exitcode is not compatible with @haveprog")

    testBoolExpression(b"((@exitcode true) @and (@exitcode true)) @and (@exitcode true)", True)
    testBoolExpression(b"((@exitcode true) @and (@exitcode true)) @and ((@exitcode true) @and (@exitcode false))", False)

    testBoolExpression(b"foo @eq foo", True)
    testBoolExpression(b"foo @eq bar", False)
    testSemanticError(b"foo @eq @false", "'@eq' does not accept objects of type Bool")
    testBoolExpression(b"(@echo foo) @eq foo", True)
    testBoolExpression(b"(@echo foo) @eq bar", False)

    testSemanticError(b"@assert", "@assert requires at least 1 argument")
    testSemanticError(b"@assert (@array)", "@assert expects a Bool but got a CommandResult")
    testAssertError(b"@assert @false")
    testCommand(b"@assert @true", 0, b"")
    testSemanticError(b"@assert true", "@assert expects a Bool but got a CommandResult")

    testSemanticError(b"@not", "@not requires at least 1 argument")
    testSemanticError(b"@not @true @and @false", "got binary expression inside ambiguous operator '@not', wrap inside (..parenthesis..)")
    # TODO: improve this error
    testSemanticError(b"@not (@array)", "unhandled Bool")
    testBoolExpression(b"@not @false", True)

    testSemanticError(b"@if", "@if requires at least 1 argument")
    testSemanticError(b"@if @false", "need more '@end'")
    testSemanticError(b"@if @true", "need more '@end'")
    testCommand(b"@if @false\n@end", 0, b"")
    testCommand(b"@if @true\n@end", 0, b"")
    testCommand(b"\n".join([
        b"@if @false",
        b"    @echo hey",
        b"@end",
    ]), 0, b"")
    testCommand(b"\n".join([
        b"@if @true",
        b"    @echo hey",
        b"@end",
    ]), 0, b"hey\n")

    testSemanticError(b"@end", "too many '@end'")
    testSemanticError(b"@assert @end", "too many '@end'")
    testSemanticError(b"@not @end", "too many '@end'")

    testError(b"(@array)", prototype.CommandWithNoArgumentsError, "got a command with no arguments",
              Options(verification_mode=False))

    testSemanticError(b"@haveprog", "@haveprog takes 1 argument but got 0")
    testSemanticError(b"@haveprog a b", "@haveprog takes 1 argument but got 2")

    #
    # The assign '=' operator
    #
    testSyntaxError(b"=foo = foo", "'=' requires space separation")
    testSyntaxError(b"foo = =foo", "'=' requires space separation")
    testSyntaxError(b"foo= bar", "'=' requires space separation")
    testSyntaxError(b"foo =bar", "'=' requires space separation")
    testSyntaxError(b"foo=bar", "'=' requires space separation")
    testSemanticError(b"=", "unexpected '='")
    testSemanticError(b"foo =", "expected 1 argument after '=' but got 0")
    testSemanticError(b"= foo", "unexpected '='")
    testSemanticError(b"= = foo", "unexpected '='")
    testSemanticError(b"foo = =", "unexpected '='")
    testSemanticError(b"foo = bar baz", "expected 1 argument after '=' but got 2")
    testSemanticError(b"@not = bar", "unexpected '='")
    testSemanticError(b"@echo =", "unexpected '='")
    testSemanticError(b"foo = @not", "expected a String, Bool or Array after '=' but got Builtin")
    testSemanticError(b"@true = bar", "expected a String before '=' but got Bool")
    testSemanticError(b"@missing = bar", "'@missing' is undefined")
    testSemanticError(b"foo = @missing", "'@missing' is undefined")
    testSemanticError(b"@not foo = bat", "unexpected '='")
    testSemanticError(b"(foo = bar)", "assignment '=' is not allowed inside an inline command")
    testCommand(b"foo = bar", 0, b"")

    testCommand(b"(@echo foo) = bar", 0, b"")
    testCommand(b"foo = @false", 0, b"")

    testSemanticError(b"@settmp", "@settmp requires at least 3 arguments but got 0")
    testSemanticError(b"@settmp a", "@settmp requires at least 3 arguments but got 1")
    testSemanticError(b"@settmp a b", "@settmp requires at least 3 arguments but got 2")

    testSemanticError(b"@isfile", "@isfile takes 1 argument but got 0")
    testSemanticError(b"@isfile foo bar", "@isfile takes 1 argument but got 2")
    testSemanticError(b"@isdir", "@isdir takes 1 argument but got 0")
    testSemanticError(b"@isdir foo bar", "@isdir takes 1 argument but got 2")

    testAssertError(b"\n".join([
        b"foo = bar",
        b"@assert $foo @eq bar",
        b"@assert @not ($foo @eq bar)",
    ]))

    testCommand(b"@echo hello", 0, b"hello\n")
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    # todo: test the same things but with a real external program, I could use the stitch intepreter itself...
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello))", 0, b"hello")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello)", b"hello")


    testSemanticError(b"@setenv", "@setenv takes 2 arguments but got 0")
    testSemanticError(b"@setenv FOO", "@setenv takes 2 arguments but got 1")
    testSemanticError(b"@setenv FOO BAR BAZ", "@setenv takes 2 arguments but got 3")
    testSemanticError(b"@setenv @false BAR", "@setenv requires 2 Strings but got Bool")
    testSemanticError(b"@setenv FOO @false", "@setenv requires 2 Strings but got Bool")
    testCommand(b"@setenv FOO BAR", 0, b"")
    # TODO: remove this if/when environment variables are no longer "sticky" across multiple ScriptContexts
    testCommand(b"@unsetenv FOO", 0, b"")

    testSemanticError(b"@env", "@env takes 1 argument but got 0")
    testSemanticError(b"@env PWD PWD", "@env takes 1 argument but got 2")
    testSemanticError(b"@env @false", "@env requires a String but got Bool")
    testError(b"@env THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'THIS_IS_NOT_DEFINED'", Options(verification_mode=False))

    testSemanticError(b"@envdefault", "@envdefault takes 2 arguments but got 0")
    testSemanticError(b"@envdefault foo", "@envdefault takes 2 arguments but got 1")
    testSemanticError(b"@envdefault foo bar baz", "@envdefault takes 2 arguments but got 3")
    testSemanticError(b"@envdefault @false foo", "@envdefault requires a String for its first argument but got Bool")
    testSemanticError(b"@envdefault foo @false", "@envdefault requires a String for its second argument but got Bool")
    testCommand(b"@envdefault THIS_IS_NOT_DEFINED foo", 0, b"foo")

    # test lazy default semantics
    testSemanticError(b"@echo (@envdefault anything @a_semantic_error)", "'@a_semantic_error' is undefined")
    testSemanticError(b"@echo (@envdefault anything $does_not_exist)", "'$does_not_exist' is undefined")
    testCommand(b"\n".join([
        b"@setenv FOO bar",
        b"@echo (@envdefault FOO $does_not_exist)",
        b"@unsetenv FOO",
    ]), 0, b"bar\n")

    testSemanticError(b"@unsetenv", "@unsetenv takes 1 argument but got 0")
    testSemanticError(b"@unsetenv PWD PWD", "@unsetenv takes 1 argument but got 2")
    testSemanticError(b"@unsetenv @false", "@unsetenv requires a String but got Bool")
    testError(b"@unsetenv THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError,
              "undefined environment variable 'THIS_IS_NOT_DEFINED'", Options(verification_mode=False))

    testError(b"@unsetenv FOO", prototype.UndefinedEnvironmentVariableError,
              "undefined environment variable 'FOO'", Options(verification_mode=False))
    testAssertError(b"\n".join([
        b"@setenv FOO bar",
        b"@assert (@env FOO) @eq bar",
        b"@assert @not ((@env FOO) @eq bar)",
    ]), Options(verification_mode=False))
    # cleanup since environment variables are global right now
    testCommand(b"@unsetenv FOO", 0, b"")
    testCommand(b"\n".join([
        b"@setenv FOO bar",
        b"@assert (@env FOO) @eq bar",
        # cleanup since environment variables are global right now
        b"@unsetenv FOO",
        b"@assert (@envdefault FOO bar) @eq bar",
    ]), 0, b"")

    testSemanticError(b"@call", "@call requires at least one argument")
    testSemanticError(b"@call @false", "@call requires Strings but got Bool")
    testError(b"@call this-file-does-not-exist", prototype.MissingStitchScript,
              "stitch script 'this-file-does-not-exist' does not exist", Options(verification_mode=False))

    testSemanticError(b"@cat a b", "'@cat' takes 0 or 1 arguments but got 2")
    testCommand(b"@cat", 0, b"what", Options(verification_mode=False, stdin=b"what"))

    #
    # Arrays
    #
    testSemanticError(b"@array @false", "@array requires Strings but got Bool")
    testSemanticError(b"@array @echo", "@array requires Strings but got Builtin '@echo'")
    testArrayExpression(b"@array", prototype.Array([]))
    testArrayExpression(b"@array a", prototype.Array(["a"]))
    testArrayExpression(b"@array a b", prototype.Array(["a", "b"]))
    testArrayExpression(b"@array a b car", prototype.Array(["a", "b", "car"]))
    testCommand(b"a = (@array)", 0, b"")
    testCommand(b"a = (@array a)", 0, b"")
    testCommand(b"a = (@array a b c)", 0, b"")
    testCommand(b"@echo (@array)", 0, b"")
    testCommand(b"@echo (@array a b c)", 0, b"a b c\n")
    testCommand(b'@assert "" @eq (@echo (@array))', 0, b"")
    testCommand(b'@assert "a b c" @eq (@echo (@array a b c))', 0, b"")
    testCommand(b"@echo foo(@array bar baz)buz", 0, b"foobarbazbuz\n")

    #
    # Pipes
    #
    testSyntaxError(b"0@pipe", "'@pipe' requires space separation")
    testSemanticError(b"@pipe", "unexpected '@pipe'")
    testSemanticError(b"a @pipe b", "@pipe not impl")
    #testCommand(b"(@echo hello) @pipe (@echo pipes)", 0, b"pipes")

    runStitchTests()

    print("test: success")

main()
