#!/usr/bin/env python3
import sys
import os
import subprocess
import inspect
from abc import ABC, abstractmethod
from typing import List, Dict, Union, Tuple, Any

import lex
import parse
import prototype

SCRIPT_DIR_STR = os.path.dirname(__file__)
SCRIPT_DIR = SCRIPT_DIR_STR.encode('utf8')

class CommandTest(ABC):
    def __init__(self, line: bytes):
        assert(isinstance(line, bytes))
        self.line = line
    @abstractmethod
    def verify(self, result, test_line):
        pass

class ErrorTest(CommandTest):
    def __init__(self, line: bytes, error_type, message):
        CommandTest.__init__(self, line)
        self.error_type = error_type
        self.message = message
    def __repr__(self):
        return "{}Test line={} message='{}'".format(self.error_type.__name__, self.line, self.message)
    def verify(self, result, test_line):
        if not isinstance(result, self.error_type):
            sys.exit("{}({}): Error: expected a {} but got {}: '{}'".format(
                __file__, test_line, self.error_type.__name__, type(result).__name__, result))
        result_msg = str(result)
        if result_msg != self.message:
            print("{}({}): Error: semantic error message does not match expected:".format(__file__, test_line))
            print("expected: {}".format(self.message))
            print("actual  : {}".format(result_msg))
            sys.exit(1)

class CommandResultTest(CommandTest):
    def __init__(self, line, exitcode, stdout: bytes):
        assert(isinstance(stdout, bytes))
        CommandTest.__init__(self, line)
        self.exitcode = exitcode
        self.stdout = stdout
    def __repr__(self):
        return "CommandResultTest line={}, exitcode={}, stdout={}".format(self.line, self.exitcode, self.stdout)
    def verify(self, result, test_line):
        if type(result) != prototype.CommandResult:
            sys.exit("{}({}): Error: expected a CommandResult but got {}: {}".format(__file__, test_line, type(result).__name__, result))
        if result.exitcode != self.exitcode:
            sys.exit("{}({}): Error: expected Command to return exitcode {} but got {}".format(
                __file__, test_line, self.exitcode, result.exitcode))
        if result.stdout != self.stdout:
            sys.exit("{}({}): Error: expected Command to print {} but got {}".format(
                __file__, test_line, self.stdout, result.stdout))

def runTests(commands: List[CommandTest], test_line: int, verification_mode: bool):
    context = prototype.ScriptContext(prototype.GlobalContext(True, SCRIPT_DIR), __file__.encode('utf8'), verification_mode)
    for cmd in commands:
        stdout_builder = prototype.StringBuilder()
        stderr_builder = prototype.StringBuilder()
        result: Any = None
        try:
            nodes, end = parse.parseCommand(cmd.line, 0, context.allstringliterals)
            assert(end == len(cmd.line))
        except lex.SyntaxError as e:
            result = e
        if not result:
            assert(len(nodes) > 0)
            result = prototype.runCommandNodes(prototype.CommandContext(
                context, parent=None, depth=0,
                capture=prototype.Capture(False, stdout_builder, stderr_builder),
                builtin_prefix_count=0, ambiguous_op=None), nodes)
            if type(result) == prototype.ExitCode:
                result = prototype.CommandResult(result.value, stdout_builder.output, stderr_builder.output)

        cmd.verify(result, test_line)

def getCallerLine():
    return inspect.getframeinfo(inspect.stack()[2][0]).lineno

def testSyntaxError(line, message):
    test = ErrorTest(line, lex.SyntaxError, message)
    print("test {}".format(test))
    runTests([test], getCallerLine(), verification_mode=True)

def testSemanticError(line, message):
    test = ErrorTest(line, prototype.SemanticError, message)
    print("{}".format(test))
    runTests([test], getCallerLine(), verification_mode=True)

def testAssertError(line, message):
    test = ErrorTest(line, prototype.AssertError, message)
    print("{}".format(test))
    runTests([test], getCallerLine(), verification_mode=False)

def testError(line, error_type, message):
    test = ErrorTest(line, error_type, message)
    print("{}".format(error_type.__name__))
    runTests([test], getCallerLine(), verification_mode=False)

def testExpression(line, expected):
    print("testExpression({}, {})".format(line, expected))
    if expected:
        command = b"@assert " + line
    else:
        command = "@assert @not ({})".format(line.decode('utf8')).encode('utf8')
    test = CommandResultTest(command, 0, b"")
    runTests([test], getCallerLine(), verification_mode=False)

def testCommands(commands, verification_mode: bool):
    print("testCommands(verification_mode={}):".format(verification_mode))
    for cmd in commands:
        print("    {}".format(cmd))
    runTests(commands, getCallerLine(), verification_mode)

def testCommand(line: bytes, exitcode, stdout: bytes):
    test = CommandResultTest(line, exitcode, stdout)
    print("{}".format(test))
    runTests([test], getCallerLine(), verification_mode=False)

def printForceNewline(s: str):
    print(s, end= "" if s.endswith("\n") else "\n")

def expectMatches(output: str, matches: List[str]):
    for match in matches:
        if match not in output:
            print("Error: did not find expected output")
            print()
            print("Expected:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(match)
            print("--------------------------------------------------------------------------------")
            print("Actual:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(output)
            print("--------------------------------------------------------------------------------")
            sys.exit(1)

def expectMatch(actual: str, expected: str):
    if actual != expected:
        print("Error: unexpectd output:")
        print("Expected: '{}'".format(expected))
        print("Actual: '{}'".format(actual))
        sys.exit(1)

def runSubProcessTest(exit_code: int, args: List[str]):
    print("Running: {}".format(args))
    result = subprocess.run(args, capture_output=True)
    if result.returncode != exit_code:
        print("Error: expected exit code {} but got {}".format(exit_code, result.returncode))
        print("STDOUT:\n--------\n{}\nSTDERR\n--------\n{}\n".format(result.stdout.decode('utf8'), result.stderr.decode('utf8')))
        sys.exit(1)
    return result.stdout, result.stderr

def runStitchTests():
    print("test: running stitch-tests...")
    stitch_args = [sys.executable, os.path.join(SCRIPT_DIR_STR, "prototype.py")]

    stdout, stderr = runSubProcessTest(0, stitch_args + ["-c", "@echo hello"])
    expectMatch(stdout.rstrip(), b"hello")

    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", "@missing"])
    expectMatch(stdout, b"")
    expectMatches(stderr, b"<the -c command>: SemanticError: '@missing' is undefined")

    if os.name == "nt":
        make_foo_cmd = "fsutil file createnew foo 0"
    else:
        make_foo_cmd = "touch foo"
    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", make_foo_cmd])
    expectMatches(stderr, [
        b"this script must be using relative filenames because the sandbox has this file ",
        b"1 file(s) were cleaned from the sandbox",
    ])

    result = subprocess.run(stitch_args + ["stitch-tests"])
    if result.returncode != 0:
        sys.exit(result.returncode)

def main():
    if os.name == "nt":
        path = os.path.join(SCRIPT_DIR_STR, "assetsfortest", "missing_windows_programs")
        os.environ["PATH"] = path + ";" + os.environ["PATH"]

    testSyntaxError(b"(", "missing close paren for: (")
    testSyntaxError(b"(foo", "missing close paren for: (foo")
    testSyntaxError(b"(a long command that demonstrates we shouldnt print this whole thing when we show an error",
                    "missing close paren for: (a long command that demonstra[..snip..]")
    testSyntaxError(b"$$", "unrecognized character sequence '$$'")
    testSyntaxError(b"@`", "unrecognized character sequence '@`'")
    testCommand(b"@echo @@", 0, b"@\n")
    testCommand(b"@echo @#", 0, b"#\n")
    testCommand(b"@echo @$", 0, b"$\n")
    testCommand(b"@echo @)", 0, b")\n")
    testCommand(b"@echo @(", 0, b"(\n")
    testCommand(b"@echo @=", 0, b"=\n")
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b"@echo @'", 0, b"'\n")

    testSemanticError(b"@multiline", "@multiline requires at least 1 argument")
    testSemanticError(b"@multiline @true", "the @multiline builtin is only supported within an (..inline command..)")
    testSemanticError(b"(@multiline @true @and @true)", "@multiline does not accept Bool")

    testSemanticError(b"@false", "unhandled Bool")
    testSemanticError(b"@true", "unhandled Bool")

    testSemanticError(b"@true dat", "unexpected Bool at the start of a command")

    testCommand(b'@echo', 0, b"")
    testCommand(b'@echo foo', 0, b"foo\n")
    testCommand(b'@echo "foo"', 0, b"foo\n")

    #
    # double-quoted string literals
    #
    testSyntaxError(b'"', 'missing double-quote to close: "')
    testSyntaxError(b'@echo "foo', 'missing double-quote to close: "foo')
    testSyntaxError(b'@echo "01234567890123456789012345678',
                    'missing double-quote to close: "01234567890123456789012345678')
    testSyntaxError(b'@echo "012345678901234567890123456789',
                    'missing double-quote to close: "01234567890123456789012345678[..snip..]')
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b'@echo "#@$()"', 0, b'#@$()\n')

    #
    # single-quoted string literals
    #
    testSyntaxError(b"'", "missing single-quote to close: '")
    testSyntaxError(b"''", "missing 2 single-quote sequence to close: ''")
    testSyntaxError(b"'''", "missing 3 single-quote sequence to close: '''")
    testSyntaxError(b"''''", "missing 4 single-quote sequence to close: ''''")
    testSyntaxError(b"'''''", "missing 5 single-quote sequence to close: '''''")
    testSyntaxError(b"''''''", "missing 6 single-quote sequence to close: ''''''")
    testSyntaxError(b"'''''''", "missing 6 single-quote sequence to close: '''''''")
    testSyntaxError(b"'a", "missing single-quote to close: 'a")
    testSyntaxError(b"''a", "missing 2 single-quote sequence to close: ''a")
    testSyntaxError(b"'''a", "missing 3 single-quote sequence to close: '''a")
    testSyntaxError(b"''''a", "missing 4 single-quote sequence to close: ''''a")
    testSyntaxError(b"@echo 'foo", "missing single-quote to close: 'foo")
    testSyntaxError(b"@echo '01234567890123456789012345678",
                    "missing single-quote to close: '01234567890123456789012345678")
    testSyntaxError(b"@echo '012345678901234567890123456789",
                    "missing single-quote to close: '01234567890123456789012345678[..snip..]")
    #testCommand(b"@echo '#@$()'", 0, b'#@$()\n')

    testSyntaxError(b"@echo '\n", "missing single-quote to close: '")
    testSyntaxError(b"@echo ''\n''", "missing 2 single-quote sequence to close: ''")
    testCommand(b"@echo '''\n'''", 0, b"")
    testCommand(b"@echo '''\nhello'''", 0, b"hello\n")
    testCommand(b"@echo '''\nhello\nworld'''", 0, b"hello\nworld\n")
    testCommand(b"@echo '''\n\"hello\"\n'world''''", 0, b"\"hello\"\n'world'\n")

    testCommand(b"@echo 'hello\"''", 0, b"hello\"'\n")
    testCommand(b"@echo ''hello\"'''", 0, b"hello\"'\n")
    testCommand(b"@echo '''hello\"''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''hello\"'''''", 0, b"hello\"'\n")
    testCommand(b"@echo '''''hello\"''''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''''hello\"'''''''", 0, b"hello\"'\n")

    # should be a syntax error because there are no quotes!
    testSyntaxError(b"@echo 'foo'", "got a single-quote string literal without double-quotes nor newlines, use double quotes instead or invoke @allstringliterals")
    testCommands([
        CommandResultTest(b"@allstringliterals", 0, b""),
        CommandResultTest(b"@echo 'foo'", 0, b"foo\n"),
    ], verification_mode=False)

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # TODO: test all the inline command prefixes
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    testSemanticError(b"@exitcode true", "the @exitcode builtin is only supported within an (..inline command..)")
    testSemanticError(b"@assert (@exitcode)", "@exitcode requires at least 1 argument")
    testSemanticError(b"@assert (@exitcode @exitcode true)", "@exitcode is not compatible with @exitcode")
    testSemanticError(b"@assert (@exitcode true @exitcode)", "cannot coerce Builtin '@exitcode' to String")
    testSemanticError(b"@assert (@exitcode @true)", "unhandled Bool")
    #testSemanticError(b"@assert (@exitcode @multiline true)", "")
    testCommand(b"@assert (@exitcode true)", 0, b"")
    testCommand(b"@assert @not (@exitcode false)", 0, b"")

    testSemanticError(b"@and", "unexpected '@and'")
    testSemanticError(b"@or", "unexpected '@or'")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"@emptyarray @and @true", "'@and' does not accept objects of type Array")
    testSemanticError(b"@true @and @emptyarray", "'@and' does not accept objects of type Array")
    testSemanticError(b"@false @and", "missing operand after '@and'")
    testSemanticError(b"(true) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"(false) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"false false @or", "unexpected '@or'")
    testSemanticError(b"(false) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@multiline true) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@and)", "unexpected '@and'")
    testSemanticError(b"(@and) @or", "unexpected '@and'")
    testSemanticError(b"@false @and false false", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @and @false false", "expected '@and' operator but got token 'false'; commands must be wrapped with (...)")
    testSemanticError(b"@false @and @false @or @false", "'@and' and '@or' cannot be chained")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"@true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"true @and (true)", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @or @false @and @false", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @or @true @and @true", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @and @true @or @true", "'@and' and '@or' cannot be chained")
    testSemanticError(b"@false @or @false @or false", "'@or' does not accept objects of type String")

    # TODO: implement stderr error messages
    testCommand(b"false", 1, b"")
    testSemanticError(b"@false @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or @false", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(true) @or (true)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (true)", "'@or' does not accept objects of type String")
    testExpression(b"(@exitcode false) @or (@exitcode false)", False)
    testExpression(b"(@exitcode false) @or (@exitcode true)", True)
    testExpression(b"@true @or @undefined", True)
    testExpression(b"@true @or $undefined", True)
    testExpression(b"(@exitcode true) @or (@exitcode @undefined)", True)
    testSemanticError(b"@true @and ($missing)", "'$missing' is undefined")
    testSemanticError(b"(true) @and (false)", "'@and' does not accept objects of type String")
    testExpression(b"(@exitcode true) @and (@exitcode false)", False)
    testSemanticError(b"(true) @and (true)", "'@and' does not accept objects of type String")
    testExpression(b"(@exitcode true) @and (@exitcode true)", True)
    testExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode false)", False)
    testExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode true)", True)
    testExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode false)", False)
    testExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode true)", True)

    testExpression(b"@false @and @false", False)
    testExpression(b"@false @and @true", False)
    testExpression(b"@true @and @false", False)
    testExpression(b"@true @and @true", True)

    testExpression(b"@false @or @false", False)
    testExpression(b"@false @or @true", True)
    testExpression(b"@true @or @false", True)
    testExpression(b"@true @or @true", True)

    testCommand(b"(@echo true)", 0, b"")

    testSemanticError(b"$missing @and @true", "'$missing' is undefined")
    testSemanticError(b"(@echo hello) @and @true", "'@and' does not accept objects of type String")
    testCommand(b"@assert (@exitcode @echo hello) @and @true", 0, b"hello\n")

    testSemanticError(b"((@echo true)) @and @true", "'@and' does not accept objects of type String")
    testExpression(b"(@exitcode (@echo true)) @and @true", True)

    testSemanticError(b"abc@false @and @true", "cannot coerce Bool to String")
    testSemanticError(b"abc@scriptfile @and @true", "'@and' does not accept objects of type String")

    testSemanticError(b"@assert (@exitcode @true @and @true)", "@exitcode is not compatible with binary expressions")
    # todo: update this test when @stderr is defined
    testSemanticError(b"@assert (@stderr @true @and @true)", "'@stderr' is undefined")

    testSemanticError(b"@assert (@exitcode @haveprog foo)", "@exitcode is not compatible with @haveprog")

    testExpression(b"((@exitcode true) @and (@exitcode true)) @and (@exitcode true)", True)
    testExpression(b"((@exitcode true) @and (@exitcode true)) @and ((@exitcode true) @and (@exitcode false))", False)

    testExpression(b"foo @eq foo", True)
    testExpression(b"foo @eq bar", False)
    testSemanticError(b"foo @eq @false", "'@eq' does not accept objects of type Bool")
    testExpression(b"(@echo foo) @eq foo", True)
    testExpression(b"(@echo foo) @eq bar", False)

    testSemanticError(b"@assert", "@assert requires at least 1 argument")
    testSemanticError(b"@assert @emptyarray", "got a command with no arguments, what should the language do here?")
    testAssertError(b"@assert @false", "@assert failed")
    testCommand(b"@assert @true", 0, b"")
    testSemanticError(b"@assert true", "@assert expects a Bool but got a CommandResult")

    testSemanticError(b"@not", "@not requires at least 1 argument")
    testSemanticError(b"@not @true @and @false", "got binary expression inside ambiguous operator '@not', wrap inside (..parenthesis..)")
    # TODO: improve this error
    testSemanticError(b"@not @emptyarray", "got a command with no arguments, what should the language do here?")
    testExpression(b"@not @false", True)

    testSemanticError(b"@if", "@if requires at least 1 argument")
    testCommand(b"@if @false", 0, b"")
    testCommand(b"@if @true", 0, b"")
    # TODO: I need to call something like testFile to test "need more '@end'"
    testCommands([
        CommandResultTest(b"@if @false", 0, b""),
        CommandResultTest(b"    @echo hey", 0, b""),
        CommandResultTest(b"@end", 0, b""),
        CommandResultTest(b"@if @true", 0, b""),
        CommandResultTest(b"    @echo hey", 0, b"hey\n"),
        CommandResultTest(b"@end", 0, b""),
    ], verification_mode=False)

    testSemanticError(b"@end", "too many '@end'")
    # need multiple lines to test this otherwise I just get "too many '@end'"
    #testSemanticError(b"@assert @end", "")
    #testSemanticError(b"@not @end", "")

    testSemanticError(b"@emptyarray", "got a command with no arguments, what should the language do here?")

    testSemanticError(b"@haveprog", "@haveprog takes 1 argument but got 0")
    testSemanticError(b"@haveprog a b", "@haveprog takes 1 argument but got 2")

    #
    # The assign '=' operator
    #
    testSemanticError(b"=", "unexpected '='")
    testSemanticError(b"foo =", "expected 1 argument after '=' but got 0")
    testSemanticError(b"= foo", "unexpected '='")
    testSemanticError(b"= = foo", "unexpected '='")
    testSemanticError(b"foo = =", "unexpected '='")
    testSemanticError(b"=foo = foo", "'=' requires space separation")
    testSemanticError(b"foo = =foo", "'=' requires space separation")
    testSemanticError(b"foo = bar baz", "expected 1 argument after '=' but got 2")
    testSemanticError(b"@not = bar", "expected a String before '=' but got Builtin")
    testSemanticError(b"@echo =", "expected 1 argument after '=' but got 0")
    testSemanticError(b"foo = @not", "expected a String or Bool after '=' but got Builtin")
    testSemanticError(b"@true = bar", "expected a String before '=' but got Bool")
    testSemanticError(b"@missing = bar", "'@missing' is undefined")
    testSemanticError(b"foo = @missing", "'@missing' is undefined")
    testSemanticError(b"@not foo = bat", "unexpected '='")
    testCommand(b"foo = bar", 0, b"")
    testSemanticError(b"foo= bar", "'=' requires space separation")
    testSemanticError(b"foo =bar", "'=' requires space separation")
    testSemanticError(b"foo=bar", "'=' requires space separation")

    testCommand(b"(@echo foo) = bar", 0, b"")
    testCommand(b"foo = @false", 0, b"")

    testSemanticError(b"@settmp", "@settmp requires at least 3 arguments but got 0")
    testSemanticError(b"@settmp a", "@settmp requires at least 3 arguments but got 1")
    testSemanticError(b"@settmp a b", "@settmp requires at least 3 arguments but got 2")

    testSemanticError(b"@isfile", "@isfile takes 1 argument but got 0")
    testSemanticError(b"@isfile foo bar", "@isfile takes 1 argument but got 2")
    testSemanticError(b"@isdir", "@isdir takes 1 argument but got 0")
    testSemanticError(b"@isdir foo bar", "@isdir takes 1 argument but got 2")

    testCommands([
        CommandResultTest(b"foo = bar", 0, b""),
        CommandResultTest(b"@assert $foo @eq bar", 0, b""),
        ErrorTest        (b"@assert @not ($foo @eq bar)", prototype.AssertError, "@assert failed"),
    ], verification_mode=False)

    testCommand(b"@echo hello", 0, b"hello\n")
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    # todo: test the same things but with a real external program, I could use the stitch intepreter itself...
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello))", 0, b"hello")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello)", b"hello")


    testSemanticError(b"@setenv", "@setenv takes 2 arguments but got 0")
    testSemanticError(b"@setenv FOO", "@setenv takes 2 arguments but got 1")
    testSemanticError(b"@setenv FOO BAR BAZ", "@setenv takes 2 arguments but got 3")
    testSemanticError(b"@setenv @false BAR", "@setenv requires 2 Strings but got Bool")
    testSemanticError(b"@setenv FOO @false", "@setenv requires 2 Strings but got Bool")
    testCommand(b"@setenv FOO BAR", 0, b"")
    # TODO: remove this if/when environment variables are no longer "sticky" across multiple ScriptContexts
    testCommand(b"@unsetenv FOO", 0, b"")

    testSemanticError(b"@env", "@env takes 1 argument but got 0")
    testSemanticError(b"@env PWD PWD", "@env takes 1 argument but got 2")
    testSemanticError(b"@env @false", "@env requires a String but got Bool")
    testError(b"@env THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'THIS_IS_NOT_DEFINED'")

    testSemanticError(b"@envdefault", "@envdefault takes 2 arguments but got 0")
    testSemanticError(b"@envdefault foo", "@envdefault takes 2 arguments but got 1")
    testSemanticError(b"@envdefault foo bar baz", "@envdefault takes 2 arguments but got 3")
    testSemanticError(b"@envdefault @false foo", "@envdefault requires a String for its first argument but got Bool")
    testSemanticError(b"@envdefault foo @false", "@envdefault requires a String for its second argument but got Bool")
    testCommand(b"@envdefault THIS_IS_NOT_DEFINED foo", 0, b"foo\n")

    # test lazy default semantics
    testSemanticError(b"@echo (@envdefault anything @a_semantic_error)", "'@a_semantic_error' is undefined")
    testCommands([
        ErrorTest(        b"@echo (@envdefault FOO $does_not_exist)", prototype.SemanticError, "'$does_not_exist' is undefined"),
        CommandResultTest(b"@setenv FOO bar", 0, b""),
        CommandResultTest(b"@echo (@envdefault FOO $does_not_exist)", 0, b"bar\n"),
        CommandResultTest(b"@unsetenv FOO", 0, b""),
    ], verification_mode=False)

    testSemanticError(b"@unsetenv", "@unsetenv takes 1 argument but got 0")
    testSemanticError(b"@unsetenv PWD PWD", "@unsetenv takes 1 argument but got 2")
    testSemanticError(b"@unsetenv @false", "@unsetenv requires a String but got Bool")
    testError(b"@unsetenv THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'THIS_IS_NOT_DEFINED'")

    testCommands([
        ErrorTest        (b"@unsetenv FOO", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'FOO'"),
        CommandResultTest(b"@setenv FOO bar", 0, b""),
        CommandResultTest(b"@assert (@env FOO) @eq bar", 0, b""),
        ErrorTest        (b"@assert @not ((@env FOO) @eq bar)", prototype.AssertError, "@assert failed"),
        # cleanup since environment variables are global right now
        CommandResultTest(b"@unsetenv FOO", 0, b""),
        CommandResultTest(b"@assert (@envdefault FOO bar) @eq bar", 0, b""),
    ], verification_mode=False)

    testSemanticError(b"@call", "@call requires at least one argument")
    testSemanticError(b"@call @false", "@call requires Strings but got Bool")
    testError(b"@call this-file-does-not-exist", prototype.MissingStitchScript, "stitch script 'this-file-does-not-exist' does not exist")

    runStitchTests()

    print("test: success")

main()
