#!/usr/bin/env python3
import sys
import os
import subprocess
import inspect

import prototype

SCRIPT_DIR = os.path.dirname(__file__)

def testSyntaxError(line, msg):
    lineno = inspect.getframeinfo(inspect.stack()[1][0]).lineno

    print("testSyntaxError('{}', '{}')".format(line, msg))
    context = prototype.ScriptContext(True, __file__, SCRIPT_DIR, verification_mode=True)
    try:
        result = prototype.runLine(context, line, print_trace=False, capture_stdout=True)
        sys.exit("{}({}): Error: expected a SyntaxError but got {}: '{}'".format(__file__, lineno, result, result.msg))
    except prototype.SyntaxError as err:
        if err.msg != msg:
            print("{}({}): Error: syntax error message does not match expected:".format(__file__, lineno))
            print("expected: {}".format(msg))
            print("actual  : {}".format(err.msg))
            sys.exit(1)

def testError(error_type, line, msg):
    lineno = inspect.getframeinfo(inspect.stack()[2][0]).lineno

    print("test{}('{}', '{}')".format(error_type.__name__, line, msg))
    context = prototype.ScriptContext(True, __file__, SCRIPT_DIR, verification_mode=True)
    result = prototype.runLine(context, line, print_trace=False, capture_stdout=True)
    if type(result) != error_type:
        sys.exit("{}({}): Error: expected a {} but got {}: '{}'".format(__file__, lineno, error_type.__name__, result, result.msg))

    if result.msg != msg:
        print("{}({}): Error: semantic error message does not match expected:".format(__file__, lineno))
        print("expected: {}".format(msg))
        print("actual  : {}".format(result.msg))
        sys.exit(1)

def testSemanticError(line, msg):
    testError(prototype.SemanticError, line, msg)

def testAssertError(line, msg):
    testError(prototype.AssertError, line, msg)

def testRunError(line, stderr):
    lineno = inspect.getframeinfo(inspect.stack()[1][0]).lineno

    print("testRunError('{}', '{}')".format(line, stderr))
    context = prototype.ScriptContext(False, __file__, SCRIPT_DIR, verification_mode=False)
    result = prototype.runLine(context, line, print_trace=False, capture_stdout=True)
    if type(result) != prototype.CommandResult:
        sys.exit("{}({}): Error: expected a CommandResult but got {}".format(__file__, lineno, result))

    if result.exitcode == 0:
        sys.exit("{}({}): Error: expected line to fail but it passed: '{}'".format(line))

    if len(result.stdout) > 0:
        sys.exit("{}({}): this code that failed unexpectedly printed to stdout: {}".format(result.stdout))

    print("TODO: verify stderr!!!!")
    #    print("{}({}): Error: semantic error message does not match expected:".format(__file__, lineno))
    #    print("expected: {}".format(msg))
    #    print("actual  : {}".format(result.msg))
    #    sys.exit(1)

def testExpression(line, expected):
    lineno = inspect.getframeinfo(inspect.stack()[1][0]).lineno

    print("testExpression('{}', {})".format(line, expected))
    context = prototype.ScriptContext(False, __file__, SCRIPT_DIR, verification_mode=False)
    result = prototype.runLine(context, line, print_trace=False, capture_stdout=True)
    if type(result) != prototype.Bool:
        sys.exit("{}({}): Error: expected a Bool but got {}".format(__file__, lineno, result))

    if result.value != expected:
        sys.exit("{}({}): Error: expected line to return {} but returned {}: '{}'".format(
            __file__, lineno, expected, result.value, line))

def testCommand(line, exitcode, stdout):
    lineno = inspect.getframeinfo(inspect.stack()[1][0]).lineno

    print("testCommand('{}', exitcode={}, stdout='{}')".format(line, exitcode, stdout))
    context = prototype.ScriptContext(False, __file__, SCRIPT_DIR, verification_mode=False)
    result = prototype.runLine(context, line, print_trace=False, capture_stdout=True)
    if type(result) != prototype.CommandResult:
        sys.exit("{}({}): Error: expected a CommandResult but got {}".format(__file__, lineno, result))

    if result.exitcode != exitcode:
        sys.exit("{}({}): Error: expected Command to return exitcode {} but got {}".format(
            __file__, lineno, exitcode, result.exitcode))
    if result.stdout != stdout:
        sys.exit("{}({}): Error: expected Command to print '{}' but got '{}'".format(
            __file__, lineno, stdout, result.stdout))


def runStitchTests():
    print("test: running stitch-tests...")
    result = subprocess.run([sys.executable, os.path.join(SCRIPT_DIR, "prototype.py"), "stitch-tests"])
    if result.returncode != 0:
        sys.exit(result.returncode)

def main():
    if os.name == "nt":
        path = os.path.join(SCRIPT_DIR, "assetsfortest", "missing_windows_programs")
        os.environ["PATH"] = path + ";" + os.environ["PATH"]

    testSemanticError("@multiline", "@multiline requires at least 1 argument")
    testSemanticError("@multiline @true", "the @multiline builtin is only supported inside a command-substitution")
    testSemanticError("(@multiline @true @and @true)", "@multiline does not accept Bool")

    testSemanticError("@false", "unhandled Bool")
    testSemanticError("@true", "unhandled Bool")

    testSemanticError("@true dat", "unexpected Bool at the start of a command")

    testCommand('@echo', 0, "")
    testCommand('@echo foo', 0, "foo")
    testCommand('@echo "foo"', 0, "foo")
    testSyntaxError('@echo "foo', "string literal '\"foo' is missing the terminating '\"' character")
    testSyntaxError('@echo "01234567890123456789012345678',
                    "string literal '\"01234567890123456789012345678' is missing the terminating '\"' character")
    testSyntaxError('@echo "012345678901234567890123456789',
                    "string literal '\"01234567890123456789012345678[..snip..]' is missing the terminating '\"' character")
    testCommand('@echo @"', 0, '"')
    testCommand('@echo "#@$()"', 0, '#@$()')

    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # TODO: test @%"..." strings
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    testSemanticError("@and", "unexpected '@and'")
    testSemanticError("@or", "unexpected '@or'")
    testSemanticError("true @and true", "'@and' does not accept objects of type String")
    testSemanticError("@emptyarray @and @true", "'@and' does not accept objects of type Array")
    testSemanticError("@true @and @emptyarray", "'@and' does not accept objects of type Array")
    testSemanticError("@false @and", "missing operand after '@and'")
    testSemanticError("(true) @and", "missing operand after '@and'")
    testSemanticError("(false) @and", "missing operand after '@and'")
    testSemanticError("false false @or", "unexpected '@or'")
    testSemanticError("(false) @or", "missing operand after '@or'")
    testSemanticError("(@multiline true) @or", "missing operand after '@or'")
    testSemanticError("(@and)", "unexpected '@and'")
    testSemanticError("(@and) @or", "unexpected '@and'")
    testSemanticError("(false) @and", "missing operand after '@and'")
    testSemanticError("(false) @and false false", "'@and' does not accept objects of type String")
    testSemanticError("(false) @and (false) false", "expected '@and' operator but got token 'false'; commands must be wrapped with (...)")
    testSemanticError("(false) @and (false) @or false", "'@and' and '@or' cannot be chained")
    testSemanticError("true @and true", "'@and' does not accept objects of type String")
    testSemanticError("(true) @and true", "'@and' does not accept objects of type String")
    testSemanticError("true @and (true)", "'@and' does not accept objects of type String")
    testSemanticError("(false) @or (false) @and (false)", "'@or' and '@and' cannot be chained")
    testSemanticError("(true) @or (true) @and (true)", "'@or' and '@and' cannot be chained")
    testSemanticError("(true) @and (true) @or (true)", "'@and' and '@or' cannot be chained")
    testSemanticError("(false) @or (false) @or false", "'@or' does not accept objects of type String")

    # TODO: implement stderr error messages
    testRunError("false", "")
    testExpression("(false) @or (false)", False)
    testExpression("(false) @or (false)", False)
    testExpression("(false) @or (true)", True)
    testExpression("(true) @or (@undefined)", True)
    # TODO: implement stderr error messages
    testSemanticError("(true) @and ($missing)", "'$missing' is undefined")
    testExpression("(true) @and (false)", False)
    testExpression("(true) @and (true)", True)
    testExpression("(false) @or (false) @or (false)", False)
    testExpression("(false) @or (false) @or (true)", True)
    testExpression("(true) @and (true) @and (false)", False)
    testExpression("(true) @and (true) @and (true)", True)

    testExpression("@false @and @false", False)
    testExpression("@false @and @true", False)
    testExpression("@true @and @false", False)
    testExpression("@true @and @true", True)

    testExpression("@false @or @false", False)
    testExpression("@false @or @true", True)
    testExpression("@true @or @false", True)
    testExpression("@true @or @true", True)

    testSemanticError("$missing @and @true", "'$missing' is undefined")
    testExpression("(@echo hello) @and @true", True)
    testExpression("((@echo true)) @and @true", True)
    testSemanticError("abc@false @and @true", "cannot coerce Bool to String")
    testSemanticError("abc@scriptfile @and @true", "'@and' does not accept objects of type String")

    testExpression("((true) @and (true)) @and (true)", True)
    testExpression("((true) @and (true)) @and ((true) @and (false))", False)

    testExpression("foo @eq foo", True)
    testExpression("foo @eq bar", False)
    testSemanticError("foo @eq @false", "'@eq' does not accept objects of type Bool")

    testAssertError("@assert @false", "@assert failed")
    testCommand("@assert @true", 0, "")
    testSemanticError("@assert true", "@assert expects a Bool but got a CommandResult")

    testSemanticError("@emptyarray", "got a command with no arguments, what should the language do here?")

    runStitchTests()

    print("test: success")

main()
