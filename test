#!/usr/bin/env python3
import sys
import os
import subprocess
import inspect
from typing import List, Dict, Union, Tuple

import prototype

SCRIPT_DIR = os.path.dirname(__file__)

class CommandTest:
    def __init__(self, line):
        self.line = line

class BoolTest(CommandTest):
    def __init__(self, line, bool_result):
        CommandTest.__init__(self, line)
        self.bool_result = bool_result
    def verify(self, result, test_line):
        if type(result) != prototype.Bool:
            sys.exit("{}({}): Error: expected a Bool but got {}".format(__file__, test_line, result))
        if result.value != self.bool_result:
            sys.exit("{}({}): Error: expected line to return {} but returned {}: '{}'".format(
                __file__, test_line, self.bool_result, result.value, line))

class ErrorTest(CommandTest):
    def __init__(self, line, error_type, msg):
        CommandTest.__init__(self, line)
        self.error_type = error_type
        self.msg = msg
    def verify(self, result, test_line):
        if type(result) != self.error_type:
            sys.exit("{}({}): Error: expected a {} but got {}: '{}'".format(__file__, test_line, self.error_type.__name__, result, result))
        if result.msg != self.msg:
            print("{}({}): Error: semantic error message does not match expected:".format(__file__, test_line))
            print("expected: {}".format(self.msg))
            print("actual  : {}".format(result.msg))
            sys.exit(1)

class CommandResultTest(CommandTest):
    def __init__(self, line, exitcode, stdout):
        CommandTest.__init__(self, line)
        self.exitcode = exitcode
        self.stdout = stdout
    def verify(self, result, test_line):
        if type(result) != prototype.CommandResult:
            sys.exit("{}({}): Error: expected a CommandResult but got {}".format(__file__, test_line, result))
        if result.exitcode != self.exitcode:
            sys.exit("{}({}): Error: expected Command to return exitcode {} but got {}".format(
                __file__, test_line, self.exitcode, result.exitcode))
        if result.stdout != self.stdout:
            sys.exit("{}({}): Error: expected Command to print '{}' but got '{}'".format(
                __file__, test_line, self.stdout, result.stdout))


def runTests(commands: List[CommandTest], test_line: int, verification_mode: bool):
    context = prototype.ScriptContext(False, __file__, SCRIPT_DIR, verification_mode)
    for cmd in commands:
        try:
            result = prototype.runLine(context, cmd.line, print_trace=False, capture_stdout=True)
        except prototype.SyntaxError as e:
            result = e
        cmd.verify(result, test_line)

def getCallerLine():
    return inspect.getframeinfo(inspect.stack()[2][0]).lineno

def testSyntaxError(line, msg):
    print("testSyntaxError('{}', '{}')".format(line, msg))
    runTests([ErrorTest(line, prototype.SyntaxError, msg)], getCallerLine(), verification_mode=True)

def testSemanticError(line, msg):
    print("testSemanticError('{}', '{}')".format(line, msg))
    runTests([ErrorTest(line, prototype.SemanticError, msg)], getCallerLine(), verification_mode=True)

def testAssertError(line, msg):
    print("testAssertError('{}', '{}')".format(line, msg))
    runTests([ErrorTest(line, prototype.AssertError, msg)], getCallerLine(), verification_mode=False)

def testExpression(line, expected):
    print("testExpression('{}', {})".format(line, expected))
    runTests([BoolTest(line, expected)], getCallerLine(), verification_mode=False)

def testCommands(commands, verification_mode: bool):
    print("testCommands(verification_mode={}):".format(verification_mode))
    for cmd in commands:
        print("    {}".format(cmd))
    runTests(commands, getCallerLine(), verification_mode)

def testCommand(line, exitcode, stdout):
    print("testCommand('{}', exitcode={}, stdout='{}')".format(line, exitcode, stdout))
    runTests([CommandResultTest(line, exitcode, stdout)], getCallerLine(), verification_mode=False)

def runStitchTests():
    print("test: running stitch-tests...")
    result = subprocess.run([sys.executable, os.path.join(SCRIPT_DIR, "prototype.py"), "stitch-tests"])
    if result.returncode != 0:
        sys.exit(result.returncode)

def main():
    if os.name == "nt":
        path = os.path.join(SCRIPT_DIR, "assetsfortest", "missing_windows_programs")
        os.environ["PATH"] = path + ";" + os.environ["PATH"]

    testSemanticError("@multiline", "@multiline requires at least 1 argument")
    testSemanticError("@multiline @true", "the @multiline builtin is only supported within an (..inline command..)")
    testSemanticError("(@multiline @true @and @true)", "@multiline does not accept Bool")

    testSemanticError("@false", "unhandled Bool")
    testSemanticError("@true", "unhandled Bool")

    testSemanticError("@true dat", "unexpected Bool at the start of a command")

    testCommand('@echo', 0, "")
    testCommand('@echo foo', 0, "foo")
    testCommand('@echo "foo"', 0, "foo")
    testSyntaxError('@echo "foo', "string literal '\"foo' is missing the terminating '\"' character")
    testSyntaxError('@echo "01234567890123456789012345678',
                    "string literal '\"01234567890123456789012345678' is missing the terminating '\"' character")
    testSyntaxError('@echo "012345678901234567890123456789',
                    "string literal '\"01234567890123456789012345678[..snip..]' is missing the terminating '\"' character")
    testCommand('@echo @"', 0, '"')
    testCommand('@echo "#@$()"', 0, '#@$()')

    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # TODO: test @%"..." strings
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    testSemanticError("@and", "unexpected '@and'")
    testSemanticError("@or", "unexpected '@or'")
    testSemanticError("true @and true", "'@and' does not accept objects of type String")
    testSemanticError("@emptyarray @and @true", "'@and' does not accept objects of type Array")
    testSemanticError("@true @and @emptyarray", "'@and' does not accept objects of type Array")
    testSemanticError("@false @and", "missing operand after '@and'")
    testSemanticError("(true) @and", "missing operand after '@and'")
    testSemanticError("(false) @and", "missing operand after '@and'")
    testSemanticError("false false @or", "unexpected '@or'")
    testSemanticError("(false) @or", "missing operand after '@or'")
    testSemanticError("(@multiline true) @or", "missing operand after '@or'")
    testSemanticError("(@and)", "unexpected '@and'")
    testSemanticError("(@and) @or", "unexpected '@and'")
    testSemanticError("(false) @and", "missing operand after '@and'")
    testSemanticError("(false) @and false false", "'@and' does not accept objects of type String")
    testSemanticError("(false) @and (false) false", "expected '@and' operator but got token 'false'; commands must be wrapped with (...)")
    testSemanticError("(false) @and (false) @or false", "'@and' and '@or' cannot be chained")
    testSemanticError("true @and true", "'@and' does not accept objects of type String")
    testSemanticError("(true) @and true", "'@and' does not accept objects of type String")
    testSemanticError("true @and (true)", "'@and' does not accept objects of type String")
    testSemanticError("(false) @or (false) @and (false)", "'@or' and '@and' cannot be chained")
    testSemanticError("(true) @or (true) @and (true)", "'@or' and '@and' cannot be chained")
    testSemanticError("(true) @and (true) @or (true)", "'@and' and '@or' cannot be chained")
    testSemanticError("(false) @or (false) @or false", "'@or' does not accept objects of type String")

    # TODO: implement stderr error messages
    testCommand("false", 1, "")
    testExpression("(false) @or (false)", False)
    testExpression("(false) @or (false)", False)
    testExpression("(false) @or (true)", True)
    testExpression("(true) @or (@undefined)", True)
    # TODO: implement stderr error messages
    testSemanticError("(true) @and ($missing)", "'$missing' is undefined")
    testExpression("(true) @and (false)", False)
    testExpression("(true) @and (true)", True)
    testExpression("(false) @or (false) @or (false)", False)
    testExpression("(false) @or (false) @or (true)", True)
    testExpression("(true) @and (true) @and (false)", False)
    testExpression("(true) @and (true) @and (true)", True)

    testExpression("@false @and @false", False)
    testExpression("@false @and @true", False)
    testExpression("@true @and @false", False)
    testExpression("@true @and @true", True)

    testExpression("@false @or @false", False)
    testExpression("@false @or @true", True)
    testExpression("@true @or @false", True)
    testExpression("@true @or @true", True)

    testSemanticError("$missing @and @true", "'$missing' is undefined")
    testExpression("(@echo hello) @and @true", True)
    testExpression("((@echo true)) @and @true", True)
    testSemanticError("abc@false @and @true", "cannot coerce Bool to String")
    testSemanticError("abc@scriptfile @and @true", "'@and' does not accept objects of type String")

    testExpression("((true) @and (true)) @and (true)", True)
    testExpression("((true) @and (true)) @and ((true) @and (false))", False)

    testExpression("foo @eq foo", True)
    testExpression("foo @eq bar", False)
    testSemanticError("foo @eq @false", "'@eq' does not accept objects of type Bool")

    testSemanticError("@assert", "@assert requires at least 1 argument")
    testSemanticError("@assert @emptyarray", "got a command with no arguments, what should the language do here?")
    testAssertError("@assert @false", "@assert failed")
    testCommand("@assert @true", 0, "")
    testSemanticError("@assert true", "@assert expects a Bool but got a CommandResult")

    testSemanticError("@not", "@not requires at least 1 argument")
    testSemanticError("@not @true @and @false", "got binary expression inside ambiguous operator '@not', wrap inside (..parenthesis..)")
    # TODO: improve this error
    testSemanticError("@not @emptyarray", "got a command with no arguments, what should the language do here?")
    testExpression("@not @false", True)

    testSemanticError("@if", "@if requires at least 1 argument")
    testCommand("@if @false", 0, "")
    testCommand("@if @true", 0, "")
    testCommand("@if false", 0, "")
    testCommand("@if true", 0, "")
    # TODO: I need to call something like testFile to test "need more '@end'"

    testSemanticError("@end", "too many '@end'")
    # need multiple lines to test this otherwise I just get "too many '@end'"
    #testSemanticError("@assert @end", "")
    #testSemanticError("@not @end", "")

    testSemanticError("@emptyarray", "got a command with no arguments, what should the language do here?")

    testSemanticError("@haveprog", "'@haveprog' expects 1 arg but got 0")
    testSemanticError("@haveprog a b", "'@haveprog' expects 1 arg but got 2")

    testSemanticError("@set", "@set expects 2 arguments but got 0")
    testSemanticError("@set foo", "@set expects 2 arguments but got 1")
    testCommand("@set foo bar", 0, "")
    testSemanticError("@set @false bar", "@set requires a String for its 1st argument but got Bool")
    testSemanticError("@set @echo bar", "@set requires a String for its 1st argument but got Builtin")
    testSemanticError("@set (@echo foo) bar", "@set requires a String for its 1st argument but got CommandResult")
    testCommand("@set foo @false", 0, "")

    testSemanticError("@isfile", "@isfile accepts 1 argument but got 0")
    testSemanticError("@isfile foo bar", "@isfile accepts 1 argument but got 2")

    testCommands([
        CommandResultTest("@set foo bar", 0, ""),
        CommandResultTest("@assert $foo @eq bar", 0, ""),
        ErrorTest        ("@assert @not ($foo @eq bar)", prototype.AssertError, "@assert failed"),
    ], verification_mode=False)


    runStitchTests()

    print("test: success")

main()
