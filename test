#!/usr/bin/env python3
import sys
import os
import subprocess
import inspect
from abc import ABC, abstractmethod
from typing import List, Dict, Union, Tuple, Any

import lex
import parse
import prototype

SCRIPT_DIR_STR = os.path.dirname(__file__)
SCRIPT_DIR = SCRIPT_DIR_STR.encode('utf8')

def runInternal(line: bytes, verification_mode: bool):
    context = prototype.ScriptContext(prototype.GlobalContext(True, SCRIPT_DIR), __file__.encode('utf8'), verification_mode)
    stdout_builder = prototype.StringBuilder()
    stderr_builder = prototype.StringBuilder()
    nodes, end = parse.parseCommand(line, 0, context.allstringliterals)
    assert(end == len(line))
    assert(len(nodes) > 0)
    result = prototype.runCommandNodes(prototype.CommandContext(
        context, parent=None, depth=0,
        capture=prototype.Capture(False, stdout_builder, stderr_builder),
        builtin_prefix_count=0, ambiguous_op=None), nodes)
    return result, stdout_builder.output, stderr_builder.output

class Expect(ABC):
    @abstractmethod
    def verify(self, result, stdout: bytes, stderr: bytes, test_line: int):
        pass
class ExpectExitAndStdout(Expect):
    def __init__(self, exitcode: int, stdout: bytes):
        self.exitcode = exitcode
        self.stdout = stdout
    def verify(self, result, stdout: bytes, stderr: bytes, test_line: int):
        if type(result) != prototype.ExitCode:
            sys.exit("{}({}): Error: expected an ExitCode but got {}: {}".format(__file__, test_line, type(result).__name__, result))
        if result.value != self.exitcode:
            sys.exit("{}({}): Error: expected Command to return exitcode {} but got {}".format(
                __file__, test_line, self.exitcode, result.exitcode.value))
        if stdout != self.stdout:
            sys.exit("{}({}): Error: expected Command to print {!r} but got {!r}".format(
                __file__, test_line, self.stdout, stdout))
class ExpectError(Expect):
    def __init__(self, error_type, message):
        self.error_type = error_type
        self.message = message
    def verify(self, result, stdout: bytes, stderr: bytes, test_line: int):
        if not isinstance(result, self.error_type):
            sys.exit("{}({}): Error: expected a {} but got {}: '{}'".format(
                __file__, test_line, self.error_type.__name__, type(result).__name__, result))
        result_msg = str(result)
        if result_msg != self.message:
            print("{}({}): Error: {} message does not match expected:".format(__file__, test_line, self.error_type.__name__))
            print("expected: {}".format(self.message))
            print("actual  : {}".format(result_msg))
            sys.exit(1)


def runTest(src: bytes, verification_mode: bool, expect: Expect, test_line: int):
    context = prototype.ScriptContext(prototype.GlobalContext(True, SCRIPT_DIR), __file__.encode('utf8'), verification_mode)
    stdout_builder = prototype.StringBuilder()
    stderr_builder = prototype.StringBuilder()

    result: Any = None
    try:
        result = prototype.runSrc(context, src, stdout_builder, stderr_builder)
    except lex.SyntaxError as e:
        result = e

    expect.verify(result, stdout_builder.output, stderr_builder.output, test_line)

def getCallerLine():
    return inspect.getframeinfo(inspect.stack()[2][0]).lineno

def testCommand(src: bytes, exitcode: int, stdout: bytes, verification_mode=False):
    expect = ExpectExitAndStdout(exitcode, stdout)
    print("testCommand({!r}, exitcode={}, stdout{!r}".format(src, exitcode, stdout))
    runTest(src, verification_mode, expect, getCallerLine())

def testError(src: bytes, error_type, message: str, verification_mode: bool=True):
    expect = ExpectError(error_type, message)
    print("testError({!r}, {}, {})".format(src, error_type.__name__, message))
    runTest(src, verification_mode, expect, getCallerLine())

def testSyntaxError(src: bytes, message: str):
    expect = ExpectError(lex.SyntaxError, message)
    print("testSyntaxError({!r}, {})".format(src, message))
    runTest(src, True, expect, getCallerLine())

def testSemanticError(src: bytes, message: str):
    expect = ExpectError(prototype.SemanticError, message)
    print("testSemanticError({!r}, {})".format(src, message))
    runTest(src, True, expect, getCallerLine())

def testAssertError(src: bytes, verification_mode=True):
    expect = ExpectError(prototype.AssertError, "@assert failed")
    print("testAssertError({!r})".format(src))
    runTest(src, verification_mode, expect, getCallerLine())

def testBoolExpression(line: bytes, expected: bool):
    print("testBoolExpression({!r}, {})".format(line, expected))
    result, stdout, stderr = runInternal(line, verification_mode=False)
    if not isinstance(result, prototype.Bool):
        sys.exit("Error: expected expression to return Bool but got {}: {}".format(type(result).__name__, result))
    assert(expected == result.value)

def testArrayExpression(line: bytes, expected: prototype.Array):
    print("testArrayExpression({!r}, {})".format(line, expected))
    result, stdout, stderr = runInternal(line, verification_mode=False)
    test_line = getCallerLine()
    if not isinstance(result, prototype.Array):
        sys.exit("Error: expected expression to return Array but got {}: {}".format(type(result).__name__, result))
    if len(expected.elements) != len(result.elements):
        sys.exit("{}({}): Error: expected an array of {} elements but got {}".format(
            __file__, test_line, len(expected.elements), len(result.elements)))
    for i in range(0, len(expected.elements)):
        if len(expected.elements[i]) != len(result.elements[i]):
            sys.exit("{}({}): Error: elements at index {} '{!r}' does not match expected '{!r}'".format(
                __file__, test_line, i, result.elements[i], expected.elements[i]))

def printForceNewline(s: str):
    print(s, end= "" if s.endswith("\n") else "\n")

def expectMatches(output: str, matches: List[str]):
    for match in matches:
        if match not in output:
            print("Error: did not find expected output")
            print()
            print("Expected:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(match)
            print("--------------------------------------------------------------------------------")
            print("Actual:")
            print("--------------------------------------------------------------------------------")
            printForceNewline(output)
            print("--------------------------------------------------------------------------------")
            sys.exit(1)

def expectMatch(actual: str, expected: str):
    if actual != expected:
        print("Error: unexpectd output:")
        print("Expected: '{}'".format(expected))
        print("Actual: '{}'".format(actual))
        sys.exit(1)

def runSubProcessTest(exit_code: int, args: List[str]):
    print("Running: {}".format(args))
    result = subprocess.run(args, capture_output=True)
    if result.returncode != exit_code:
        print("Error: expected exit code {} but got {}".format(exit_code, result.returncode))
        print("STDOUT:\n--------\n{}\nSTDERR\n--------\n{}\n".format(result.stdout.decode('utf8'), result.stderr.decode('utf8')))
        sys.exit(1)
    return result.stdout, result.stderr

def runStitchTests():
    print("test: running stitch-tests...")
    stitch_args = [sys.executable, os.path.join(SCRIPT_DIR_STR, "prototype.py")]

    stdout, stderr = runSubProcessTest(0, stitch_args + ["-c", "@echo hello"])
    expectMatch(stdout.rstrip(), b"hello")

    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", "@missing"])
    expectMatch(stdout, b"")
    expectMatches(stderr, b"<the -c command>: SemanticError: '@missing' is undefined")

    if os.name == "nt":
        make_foo_cmd = "fsutil file createnew foo 0"
    else:
        make_foo_cmd = "touch foo"
    stdout, stderr = runSubProcessTest(1, stitch_args + ["-c", make_foo_cmd])
    expectMatches(stderr, [
        b"this script must be using relative filenames because the sandbox has this file ",
        b"1 file(s) were cleaned from the sandbox",
    ])

    result = subprocess.run(stitch_args + ["stitch-tests"])
    if result.returncode != 0:
        sys.exit(result.returncode)

def main():
    if os.name == "nt":
        path = os.path.join(SCRIPT_DIR_STR, "assetsfortest", "missing_windows_programs")
        os.environ["PATH"] = path + ";" + os.environ["PATH"]

    testSyntaxError(b"(", "missing close paren for: (")
    testSyntaxError(b"(foo", "missing close paren for: (foo")
    testSyntaxError(b"(a long command that demonstrates we shouldnt print this whole thing when we show an error",
                    "missing close paren for: (a long command that demonstra[..snip..]")
    testSyntaxError(b"$$", "unrecognized character sequence '$$'")
    testSyntaxError(b"@`", "unrecognized character sequence '@`'")
    testCommand(b"@echo @@", 0, b"@\n")
    testCommand(b"@echo @#", 0, b"#\n")
    testCommand(b"@echo @$", 0, b"$\n")
    testCommand(b"@echo @)", 0, b")\n")
    testCommand(b"@echo @(", 0, b"(\n")
    testCommand(b"@echo @=", 0, b"=\n")
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b"@echo @'", 0, b"'\n")

    testSemanticError(b"@multiline", "@multiline requires at least 1 argument")
    testSemanticError(b"@multiline @true", "the @multiline builtin is only supported within an (..inline command..)")
    testSemanticError(b"(@multiline @true @and @true)", "@multiline does not accept Bool")

    testSemanticError(b"@false", "unhandled Bool")
    testSemanticError(b"@true", "unhandled Bool")

    testSemanticError(b"@true dat", "unexpected Bool at the start of a command")

    testCommand(b'@echo', 0, b"")
    testCommand(b'@echo foo', 0, b"foo\n")
    testCommand(b'@echo "foo"', 0, b"foo\n")

    #
    # double-quoted string literals
    #
    testSyntaxError(b'"', 'missing double-quote to close: "')
    testSyntaxError(b'@echo "foo', 'missing double-quote to close: "foo')
    testSyntaxError(b'@echo "01234567890123456789012345678',
                    'missing double-quote to close: "01234567890123456789012345678')
    testSyntaxError(b'@echo "012345678901234567890123456789',
                    'missing double-quote to close: "01234567890123456789012345678[..snip..]')
    testCommand(b'@echo @"', 0, b'"\n')
    testCommand(b'@echo "#@$()"', 0, b'#@$()\n')

    #
    # single-quoted string literals
    #
    testSyntaxError(b"'", "missing single-quote to close: '")
    testSyntaxError(b"''", "missing 2 single-quote sequence to close: ''")
    testSyntaxError(b"'''", "missing 3 single-quote sequence to close: '''")
    testSyntaxError(b"''''", "missing 4 single-quote sequence to close: ''''")
    testSyntaxError(b"'''''", "missing 5 single-quote sequence to close: '''''")
    testSyntaxError(b"''''''", "missing 6 single-quote sequence to close: ''''''")
    testSyntaxError(b"'''''''", "missing 6 single-quote sequence to close: '''''''")
    testSyntaxError(b"'a", "missing single-quote to close: 'a")
    testSyntaxError(b"''a", "missing 2 single-quote sequence to close: ''a")
    testSyntaxError(b"'''a", "missing 3 single-quote sequence to close: '''a")
    testSyntaxError(b"''''a", "missing 4 single-quote sequence to close: ''''a")
    testSyntaxError(b"@echo 'foo", "missing single-quote to close: 'foo")
    testSyntaxError(b"@echo '01234567890123456789012345678",
                    "missing single-quote to close: '01234567890123456789012345678")
    testSyntaxError(b"@echo '012345678901234567890123456789",
                    "missing single-quote to close: '01234567890123456789012345678[..snip..]")
    #testCommand(b"@echo '#@$()'", 0, b'#@$()\n')

    testSyntaxError(b"@echo '\n", "missing single-quote to close: '")
    testSyntaxError(b"@echo ''\n''", "missing 2 single-quote sequence to close: ''")
    testCommand(b"@echo '''\n'''", 0, b"")
    testCommand(b"@echo '''\nhello'''", 0, b"hello\n")
    testCommand(b"@echo '''\nhello\nworld'''", 0, b"hello\nworld\n")
    testCommand(b"@echo '''\n\"hello\"\n'world''''", 0, b"\"hello\"\n'world'\n")

    testCommand(b"@echo 'hello\"'", 0, b"hello\"\n")
    testCommand(b"@echo ''hello\"'''", 0, b"hello\"'\n")
    testCommand(b"@echo '''hello\"''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''hello\"'''''", 0, b"hello\"'\n")
    testCommand(b"@echo '''''hello\"''''''", 0, b"hello\"'\n")
    testCommand(b"@echo ''''''hello\"'''''''", 0, b"hello\"'\n")

    # should be a syntax error because there are no quotes!
    testSyntaxError(b"@echo 'foo'", "got a single-quote string literal without double-quotes nor newlines, use double quotes instead or invoke @allstringliterals")
    testCommand(b"@allstringliterals\n@echo 'foo'", 0, b"foo\n")
    testCommand(b"\n".join([
        b"name = joe",
        b"age = 64",
        b"@echo '''\nhello '''$name''', you're\n64!!!\n'''"]
    ), 0, b"hello joe, you're\n64!!!\n")

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # TODO: test all the inline command prefixes
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    testSemanticError(b"@exitcode true", "the @exitcode builtin is only supported within an (..inline command..)")
    testSemanticError(b"@assert (@exitcode)", "@exitcode requires at least 1 argument")
    testSemanticError(b"@assert (@exitcode @exitcode true)", "@exitcode is not compatible with @exitcode")
    testSemanticError(b"@assert (@exitcode true @exitcode)", "cannot coerce Builtin '@exitcode' to String")
    testSemanticError(b"@assert (@exitcode @true)", "unhandled Bool")
    #testSemanticError(b"@assert (@exitcode @multiline true)", "")
    testCommand(b"@assert (@exitcode true)", 0, b"")
    testCommand(b"@assert @not (@exitcode false)", 0, b"")

    testSemanticError(b"@and", "unexpected '@and'")
    testSemanticError(b"@or", "unexpected '@or'")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"(@array) @and @true", "'@and' does not accept objects of type Array")
    testSemanticError(b"@true @and (@array)", "'@and' does not accept objects of type Array")
    testSemanticError(b"@false @and", "missing operand after '@and'")
    testSemanticError(b"(true) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"(false) @and", "'@and' does not accept objects of type String")
    testSemanticError(b"false false @or", "unexpected '@or'")
    testSemanticError(b"(false) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@multiline true) @or", "'@or' does not accept objects of type String")
    testSemanticError(b"(@and)", "unexpected '@and'")
    testSemanticError(b"(@and) @or", "unexpected '@and'")
    testSemanticError(b"@false @and false false", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @and @false false", "expected '@and' operator but got token 'false'; commands must be wrapped with (...)")
    testSemanticError(b"@false @and @false @or @false", "'@and' and '@or' cannot be chained")
    testSemanticError(b"true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"@true @and true", "'@and' does not accept objects of type String")
    testSemanticError(b"true @and (true)", "'@and' does not accept objects of type String")
    testSemanticError(b"@false @or @false @and @false", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @or @true @and @true", "'@or' and '@and' cannot be chained")
    testSemanticError(b"@true @and @true @or @true", "'@and' and '@or' cannot be chained")
    testSemanticError(b"@false @or @false @or false", "'@or' does not accept objects of type String")

    # TODO: implement stderr error messages
    testCommand(b"false", 1, b"")
    testSemanticError(b"@false @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or @false", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (false)", "'@or' does not accept objects of type String")
    testSemanticError(b"(true) @or (true)", "'@or' does not accept objects of type String")
    testSemanticError(b"(false) @or (true)", "'@or' does not accept objects of type String")
    testBoolExpression(b"(@exitcode false) @or (@exitcode false)", False)
    testBoolExpression(b"(@exitcode false) @or (@exitcode true)", True)
    testBoolExpression(b"@true @or @undefined", True)
    testBoolExpression(b"@true @or $undefined", True)
    testBoolExpression(b"(@exitcode true) @or (@exitcode @undefined)", True)
    testSemanticError(b"@true @and ($missing)", "'$missing' is undefined")
    testSemanticError(b"(true) @and (false)", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode true) @and (@exitcode false)", False)
    testSemanticError(b"(true) @and (true)", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode true) @and (@exitcode true)", True)
    testBoolExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode false)", False)
    testBoolExpression(b"(@exitcode false) @or (@exitcode false) @or (@exitcode true)", True)
    testBoolExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode false)", False)
    testBoolExpression(b"(@exitcode true) @and (@exitcode true) @and (@exitcode true)", True)

    testBoolExpression(b"@false @and @false", False)
    testBoolExpression(b"@false @and @true", False)
    testBoolExpression(b"@true @and @false", False)
    testBoolExpression(b"@true @and @true", True)

    testBoolExpression(b"@false @or @false", False)
    testBoolExpression(b"@false @or @true", True)
    testBoolExpression(b"@true @or @false", True)
    testBoolExpression(b"@true @or @true", True)

    testCommand(b"(@echo true)", 0, b"")

    testSemanticError(b"$missing @and @true", "'$missing' is undefined")
    testSemanticError(b"(@echo hello) @and @true", "'@and' does not accept objects of type String")
    testCommand(b"@assert (@exitcode @echo hello) @and @true", 0, b"hello\n")

    testSemanticError(b"((@echo true)) @and @true", "'@and' does not accept objects of type String")
    testBoolExpression(b"(@exitcode (@echo true)) @and @true", True)

    testSemanticError(b"abc@false @and @true", "cannot coerce Bool to String")
    testSemanticError(b"abc@scriptfile @and @true", "'@and' does not accept objects of type String")

    testSemanticError(b"@assert (@exitcode @true @and @true)", "@exitcode is not compatible with binary expressions")
    # todo: update this test when @stderr is defined
    testSemanticError(b"@assert (@stderr @true @and @true)", "'@stderr' is undefined")

    testSemanticError(b"@assert (@exitcode @haveprog foo)", "@exitcode is not compatible with @haveprog")

    testBoolExpression(b"((@exitcode true) @and (@exitcode true)) @and (@exitcode true)", True)
    testBoolExpression(b"((@exitcode true) @and (@exitcode true)) @and ((@exitcode true) @and (@exitcode false))", False)

    testBoolExpression(b"foo @eq foo", True)
    testBoolExpression(b"foo @eq bar", False)
    testSemanticError(b"foo @eq @false", "'@eq' does not accept objects of type Bool")
    testBoolExpression(b"(@echo foo) @eq foo", True)
    testBoolExpression(b"(@echo foo) @eq bar", False)

    testSemanticError(b"@assert", "@assert requires at least 1 argument")
    testSemanticError(b"@assert (@array)", "got a command with no arguments, what should the language do here?")
    testAssertError(b"@assert @false")
    testCommand(b"@assert @true", 0, b"")
    testSemanticError(b"@assert true", "@assert expects a Bool but got a CommandResult")

    testSemanticError(b"@not", "@not requires at least 1 argument")
    testSemanticError(b"@not @true @and @false", "got binary expression inside ambiguous operator '@not', wrap inside (..parenthesis..)")
    # TODO: improve this error
    testSemanticError(b"@not (@array)", "got a command with no arguments, what should the language do here?")
    testBoolExpression(b"@not @false", True)

    testSemanticError(b"@if", "@if requires at least 1 argument")
    testSemanticError(b"@if @false", "need more '@end'")
    testSemanticError(b"@if @true", "need more '@end'")
    testCommand(b"@if @false\n@end", 0, b"")
    testCommand(b"@if @true\n@end", 0, b"")
    testCommand(b"\n".join([
        b"@if @false",
        b"    @echo hey",
        b"@end",
    ]), 0, b"")
    testCommand(b"\n".join([
        b"@if @true",
        b"    @echo hey",
        b"@end",
    ]), 0, b"hey\n")

    testSemanticError(b"@end", "too many '@end'")
    # need multiple lines to test this otherwise I just get "too many '@end'"
    #testSemanticError(b"@assert @end", "")
    #testSemanticError(b"@not @end", "")

    testSemanticError(b"(@array)", "got a command with no arguments, what should the language do here?")

    testSemanticError(b"@haveprog", "@haveprog takes 1 argument but got 0")
    testSemanticError(b"@haveprog a b", "@haveprog takes 1 argument but got 2")

    #
    # The assign '=' operator
    #
    testSemanticError(b"=", "unexpected '='")
    testSemanticError(b"foo =", "expected 1 argument after '=' but got 0")
    testSemanticError(b"= foo", "unexpected '='")
    testSemanticError(b"= = foo", "unexpected '='")
    testSemanticError(b"foo = =", "unexpected '='")
    testSemanticError(b"=foo = foo", "'=' requires space separation")
    testSemanticError(b"foo = =foo", "'=' requires space separation")
    testSemanticError(b"foo = bar baz", "expected 1 argument after '=' but got 2")
    testSemanticError(b"@not = bar", "expected a String before '=' but got Builtin")
    testSemanticError(b"@echo =", "expected 1 argument after '=' but got 0")
    testSemanticError(b"foo = @not", "expected a String, Bool or Array after '=' but got Builtin")
    testSemanticError(b"@true = bar", "expected a String before '=' but got Bool")
    testSemanticError(b"@missing = bar", "'@missing' is undefined")
    testSemanticError(b"foo = @missing", "'@missing' is undefined")
    testSemanticError(b"@not foo = bat", "unexpected '='")
    testCommand(b"foo = bar", 0, b"")
    testSemanticError(b"foo= bar", "'=' requires space separation")
    testSemanticError(b"foo =bar", "'=' requires space separation")
    testSemanticError(b"foo=bar", "'=' requires space separation")

    testCommand(b"(@echo foo) = bar", 0, b"")
    testCommand(b"foo = @false", 0, b"")

    testSemanticError(b"@settmp", "@settmp requires at least 3 arguments but got 0")
    testSemanticError(b"@settmp a", "@settmp requires at least 3 arguments but got 1")
    testSemanticError(b"@settmp a b", "@settmp requires at least 3 arguments but got 2")

    testSemanticError(b"@isfile", "@isfile takes 1 argument but got 0")
    testSemanticError(b"@isfile foo bar", "@isfile takes 1 argument but got 2")
    testSemanticError(b"@isdir", "@isdir takes 1 argument but got 0")
    testSemanticError(b"@isdir foo bar", "@isdir takes 1 argument but got 2")

    testAssertError(b"\n".join([
        b"foo = bar",
        b"@assert $foo @eq bar",
        b"@assert @not ($foo @eq bar)",
    ]))

    testCommand(b"@echo hello", 0, b"hello\n")
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    # todo: test the same things but with a real external program, I could use the stitch intepreter itself...
    testCommand(b"@assert (@exitcode @echo hello)", 0, b"hello\n")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello))", 0, b"hello")
    #testCommand(b"@assert ("" @eq (@stderr @echo hello)", b"hello")


    testSemanticError(b"@setenv", "@setenv takes 2 arguments but got 0")
    testSemanticError(b"@setenv FOO", "@setenv takes 2 arguments but got 1")
    testSemanticError(b"@setenv FOO BAR BAZ", "@setenv takes 2 arguments but got 3")
    testSemanticError(b"@setenv @false BAR", "@setenv requires 2 Strings but got Bool")
    testSemanticError(b"@setenv FOO @false", "@setenv requires 2 Strings but got Bool")
    testCommand(b"@setenv FOO BAR", 0, b"")
    # TODO: remove this if/when environment variables are no longer "sticky" across multiple ScriptContexts
    testCommand(b"@unsetenv FOO", 0, b"")

    testSemanticError(b"@env", "@env takes 1 argument but got 0")
    testSemanticError(b"@env PWD PWD", "@env takes 1 argument but got 2")
    testSemanticError(b"@env @false", "@env requires a String but got Bool")
    testError(b"@env THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'THIS_IS_NOT_DEFINED'", verification_mode=False)

    testSemanticError(b"@envdefault", "@envdefault takes 2 arguments but got 0")
    testSemanticError(b"@envdefault foo", "@envdefault takes 2 arguments but got 1")
    testSemanticError(b"@envdefault foo bar baz", "@envdefault takes 2 arguments but got 3")
    testSemanticError(b"@envdefault @false foo", "@envdefault requires a String for its first argument but got Bool")
    testSemanticError(b"@envdefault foo @false", "@envdefault requires a String for its second argument but got Bool")
    testCommand(b"@envdefault THIS_IS_NOT_DEFINED foo", 0, b"foo\n")

    # test lazy default semantics
    testSemanticError(b"@echo (@envdefault anything @a_semantic_error)", "'@a_semantic_error' is undefined")
    testSemanticError(b"@echo (@envdefault anything $does_not_exist)", "'$does_not_exist' is undefined")
    testCommand(b"\n".join([
        b"@setenv FOO bar",
        b"@echo (@envdefault FOO $does_not_exist)",
        b"@unsetenv FOO",
    ]), 0, b"bar\n")

    testSemanticError(b"@unsetenv", "@unsetenv takes 1 argument but got 0")
    testSemanticError(b"@unsetenv PWD PWD", "@unsetenv takes 1 argument but got 2")
    testSemanticError(b"@unsetenv @false", "@unsetenv requires a String but got Bool")
    testError(b"@unsetenv THIS_IS_NOT_DEFINED", prototype.UndefinedEnvironmentVariableError,
              "undefined environment variable 'THIS_IS_NOT_DEFINED'", verification_mode=False)

    testError(b"@unsetenv FOO", prototype.UndefinedEnvironmentVariableError, "undefined environment variable 'FOO'", verification_mode=False)
    testAssertError(b"\n".join([
        b"@setenv FOO bar",
        b"@assert (@env FOO) @eq bar",
        b"@assert @not ((@env FOO) @eq bar)",
    ]), verification_mode=False)
    # cleanup since environment variables are global right now
    testCommand(b"@unsetenv FOO", 0, b"")
    testCommand(b"\n".join([
        b"@setenv FOO bar",
        b"@assert (@env FOO) @eq bar",
        # cleanup since environment variables are global right now
        b"@unsetenv FOO",
        b"@assert (@envdefault FOO bar) @eq bar",
    ]), 0, b"")

    testSemanticError(b"@call", "@call requires at least one argument")
    testSemanticError(b"@call @false", "@call requires Strings but got Bool")
    testError(b"@call this-file-does-not-exist", prototype.MissingStitchScript,
              "stitch script 'this-file-does-not-exist' does not exist", verification_mode=False)

    #
    # Arrays
    #
    testSemanticError(b"@array @false", "@array requires Strings but got Bool")
    testSemanticError(b"@array @echo", "@array requires Strings but got Builtin '@echo'")
    testArrayExpression(b"@array", prototype.Array([]))
    testArrayExpression(b"@array a", prototype.Array(["a"]))
    testArrayExpression(b"@array a b", prototype.Array(["a", "b"]))
    testArrayExpression(b"@array a b car", prototype.Array(["a", "b", "car"]))
    testCommand(b"a = (@array)", 0, b"")
    testCommand(b"a = (@array a)", 0, b"")
    testCommand(b"a = (@array a b c)", 0, b"")
    testCommand(b"@echo (@array)", 0, b"")
    testCommand(b"@echo (@array a b c)", 0, b"a b c\n")
    testCommand(b'@assert "" @eq (@echo (@array))', 0, b"")
    testCommand(b'@assert "a b c" @eq (@echo (@array a b c))', 0, b"")

    runStitchTests()

    print("test: success")

main()
